{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"async Bakal\u00e1\u0159i API v3","text":"<p>Upozorn\u011bn\u00ed</p> <p>Tato API je st\u00e1le vyv\u00edjena, a proto podporuje jen mal\u00e9 mno\u017estv\u00ed endpoint\u016f. Nicm\u00e9n\u011b moduly zve\u0159ejn\u011bn\u00e9 v t\u00e9to dokumentaci jsou ji\u017e stabiln\u00ed.</p> <p><code>async Bakal\u00e1\u0159i API v3</code> je asynchronn\u00ed klient pro komunikaci se \u0161kolami, kter\u00e9 jsou zapojeny do programu Bakal\u00e1\u0159i. Seznam v\u0161ech \u0161kol zapojen\u00fdch do programu Bakal\u00e1\u0159i lze z\u00edskat t\u00e9\u017e z tohoto modulu.</p>"},{"location":"#instalace","title":"Instalace","text":"<p>Modul lze nainstalovat jako bal\u00ed\u010dek z PyPI nebo st\u00e1hnout z GitHubu.</p> <p>Minim\u00e1ln\u00ed verze Pythonu pro tento bal\u00ed\u010dek je 3.12</p>  PyPI GitHub <pre><code>python3 -m pip install async_bakalari_api\n</code></pre> <pre><code>python3 -m pip install \"git+https://github.com/schizza/async-bakalari-api3.git#egg=async-bakalari-api\"\n</code></pre> <p>CLI</p> <p>Po instalaci bal\u00ed\u010dku je dostupn\u00e9 jednoduch\u00e9 CLI - <code>bakalari</code></p>"},{"location":"bakalari/","title":"modul Bakalari","text":"<p>Z\u00e1kladn\u00ed modul <code>Bakalari</code> se star\u00e1 o komunikaci endpoint\u016f se serverem \u0161koly. Udr\u017euje <code>Credentials</code>, prov\u00e1d\u00ed prvn\u00ed p\u0159ihl\u00e1\u0161en\u00ed a umo\u017e\u0148uje st\u00e1hnout platn\u00fd seznam \u0161kol, ke kter\u00fdm se lze p\u0159ipojit.</p>"},{"location":"bakalari/#trida-bakalari","title":"t\u0159\u00edda Bakalari","text":"class Bakalari<pre><code>class Bakalari (self, \n    server = str | None = None, \n    auto_cache_credentials: bool = False, \n    cache_filename: str | None = None):\n</code></pre> <p>Jako argumenty t\u0159\u00edda p\u0159ij\u00edm\u00e1:</p> <ul> <li>server (str): adresa serveru \u0161koly, se kterou chceme komunikovat</li> <li>auto_cache_credentials (bool, optional): umo\u017e\u0148uje automatick\u00e9 ukl\u00e1d\u00e1n\u00ed <code>access_tokenu</code> a <code>refresh_tokenu</code> do souboru a jejich mo\u017en\u00e9 op\u011btovn\u00e9 pou\u017eit\u00ed p\u0159i dal\u0161\u00edm b\u011bhu programu</li> <li>cache_filename (str, optional): pokud je nastaveno automatick\u00e9 ukl\u00e1d\u00e1n\u00ed token\u016f, pak je nutn\u00e9 zadat i jm\u00e9no souboru, kam se maj\u00ed tokeny ukl\u00e1dat.</li> </ul> <p>Exception</p> <p>t\u0159\u00edda vrac\u00ed chybu <code>Ex.CacheError</code>, pokud je povoleno automatick\u00e9 ukl\u00e1d\u00e1n\u00ed <code>Credentials</code> a nen\u00ed vypln\u011bn\u00e9 <code>cache_filename</code></p>"},{"location":"bakalari/#inicializace-tridy","title":"Inicializace t\u0159\u00eddy","text":"<p>T\u0159\u00eddu lze inicializovat bez zad\u00e1n\u00ed parametr\u016f jako je <code>server</code>, nicm\u00e9n\u011b, pak lze stahovat jen seznam \u0161kol, pop\u0159\u00edpad\u011b zad\u00e1vat neautorizovan\u00e9 dotazy p\u0159\u00edmo na server <code>bakalari.cz</code></p> <p>Inicializace t\u0159\u00eddy Bakalari</p> s ke\u0161ov\u00e1n\u00edmbez ke\u0161ov\u00e1n\u00ed <pre><code>from async_bakalari_api import Bakalari\n\nbakalari = Bakalari(\"http://server_skoly.cz\",\n    auto_cache_credentials=True,\n    cache_filename=\"credentials_cache.json\")\n</code></pre> <pre><code>from async_bakalari_api import Bakalari\n\nbakalari = Bakalari(\"http://server_skoly.cz\")\n</code></pre>"},{"location":"bakalari/credentials/","title":"Credentials","text":"<p>Samotn\u00e9 tokeny i s <code>username</code> i <code>user_id</code> lze spravovat p\u0159es prom\u011bnou <code>Bakalari.credentials</code></p> <p>Heslo se do ke\u0161ovac\u00edho souboru neukl\u00e1d\u00e1, nen\u00ed dostupn\u00e9 ani v prom\u011bnn\u00e9 <code>credentials</code></p> <p>Poj\u010fme se kouknout na t\u0159\u00eddu <code>Credentials</code>, kter\u00e1 se nach\u00e1z\u00ed v <code>async_bakalari_api.datastructure</code></p> class Credentials <pre><code>    @dataclass\n    class Credentials:\n        \"\"\"Credentials holder.\"\"\"\n\n        username: str = None\n        access_token: str = None\n        refresh_token: str = None\n        user_id: str = None\n\n        @classmethod\n        def create(cls, data: dict[str, Any]) -&gt; Credentials:\n            ...\n\n        @classmethod\n        def create_from_json(cls, data: dict[str, Any]) -&gt; Credentials:\n            \"\"\"Return class object from JSON dictionary.\"\"\"\n            ...\n</code></pre> <p>P\u0159istupovat k aktu\u00e1ln\u00edm dat\u016fm lze z instance <code>Bakalari</code></p> <pre><code>    username = Bakalari.credentials.name\n    access_token = Bakalari.credentials.access_token\n    refresh_toke = Bakalari.credentials.refres_token\n    user_id = Bakalari.credentials.user_id\n</code></pre> <p>Zaps\u00e1n\u00ed nov\u00fdch \u00fadaj\u016f lze p\u0159\u00edmo, je ale vhodn\u011bj\u0161\u00ed vyu\u017e\u00edt metodu <code>create</code> nebo <code>create_from_json()</code>. P\u0159i\u010dem\u017e <code>create_from_json()</code> je preferovan\u011bj\u0161\u00ed. </p> <p>U metody <code>create()</code> se p\u0159edpokl\u00e1d\u00e1 datov\u00e9 pole takov\u00e9, kter\u00e9 zas\u00edl\u00e1 p\u0159\u00edmo server:</p> create()create_from_json() <pre><code>    from async_bakalari_api.datastructure import Credentials\n    from async_bakalari_api import Bakalari\n\n    bakalari = Bakalari()\n\n    nove_udaje = {\n        \"bak:UserID\": \"user_id\",\n        \"access_token\": \"nov\u00fd access_token\"\n        \"refresh_token\": \"nov\u00fd refresh_token\",\n        \"username\": \"nov\u00e9 username\"\n    }\n\n    bakalari.credentials = Credentials.create(nove_udaje)\n</code></pre> <pre><code>    from async_bakalari_api.datastructure import Credentials\n    from async_bakalari_api import Bakalari\n\n    bakalari = Bakalari()\n\n    nove_udaje = {\n        \"user_id\": \"nov\u00e9 user_id\n        \"access_token\": \"nov\u00fd access_token\"\n        \"refresh_token\": \"nov\u00fd refresh_token\",\n        \"username\": \"nov\u00e9 username\"\n    }\n\n    bakalari.credentials = Credentials.create_from_json(nove_udaje)\n</code></pre>"},{"location":"bakalari/credentials/#nahrani-ulozenych-udaju","title":"Nahr\u00e1n\u00ed ulo\u017een\u00fdch \u00fadaj\u016f","text":"<p>Jak ji\u017e bylo \u0159e\u010deno, <code>Bakalari</code> umo\u017e\u0148uj\u00ed automatick\u00e9 ukl\u00e1d\u00e1n\u00ed <code>Credentials</code> do souboru ve form\u00e1tu <code>json</code></p> <p>Jejich z\u00edsk\u00e1n\u00ed zp\u011bt je mo\u017en\u00e9 pomoc\u00ed metody <code>load_credentials</code></p> <p>load_credentials(self, filename: str) -&gt; Credentials | bool</p> <p>Jako argument se zad\u00e1v\u00e1 jm\u00e9no souboru. Vrac\u00ed <code>Credentials</code>, kter\u00e9 tak\u00e9 hned ukl\u00e1d\u00e1 do <code>Bakalari.credentials</code></p> <p>P\u0159i ne\u00fasp\u011bchu vrac\u00ed <code>False</code></p> <p>Po zvol\u00e1n\u00ed metody <code>load_credentials</code> m\u00e1me tedy v instanci <code>bakalari</code> aktu\u00e1ln\u00ed \u00fadaje a lze je vyu\u017e\u00edt rovnou p\u0159i p\u0159ihl\u00e1\u0161en\u00ed.</p> <pre><code>    from async_bakalari_api.datastructure import Schools\n    from async_bakalari_api import Bakalari\n\n    school: Schools = await Schools().load_from_file(\"schools_data.json\")\n    bakalari = Bakalari(\n        server=school.get_url(\"\u010d\u00e1st jm\u00e9na \u0161koly\"), \n        auto_cache_credentials=True,\n        cache_file=\"credetials.json\"\n    )\n    bakalari.load_credentials(\"credentials.json\")\n\n    ... nyn\u00ed ji\u017e m\u016f\u017eeme prov\u00e1d\u011bt autorizovan\u00e9 dotazy na server \u0161koly\n</code></pre>"},{"location":"bakalari/first_login/","title":"P\u0159ihl\u00e1\u0161en\u00ed jm\u00e9nem a heslem (prvn\u00ed p\u0159ihl\u00e1\u0161en\u00ed)","text":"<pre><code>async def first_login(self, username: str, password: str) -&gt; Credentials:\n</code></pre> <p>Exceptions</p> <p>Pokud jsou zad\u00e1ny \u0161patn\u00e9 p\u0159\u00edstupov\u00e9 \u00fadaje vyvol\u00e1 funkce v\u00fdjimku <code>Ex.InvalidLogin</code></p> <p>Pro z\u00edsk\u00e1n\u00ed nov\u00e9ho <code>access_tokenu</code> a <code>refresh_tokenu</code> se pou\u017e\u00edv\u00e1 funkce <code>first_login</code>. Tato funkce se takt\u00e9\u017e vol\u00e1 p\u0159i vypr\u0161en\u00ed <code>refresh_tokenu</code>, kdy ji\u017e nelze automaticky z\u00edskat <code>access_token</code>.</p> <p>Zavol\u00e1n\u00edm <code>first_login</code> se <code>Credentials</code> ulo\u017e\u00ed do <code>Bakalari.credentials</code> a z\u00e1rove\u0148 jsou nov\u00e9 p\u0159\u00edstupov\u00e9 \u00fadaje vr\u00e1ceny zp\u011bt, pokud je chcete ukl\u00e1dat n\u011bkam do datab\u00e1ze.</p> <p>Automatick\u00e9 ukl\u00e1d\u00e1n\u00ed p\u0159\u00edstupov\u00fdch \u00fadaj\u016f</p> <p>Pokud je zapnut\u00e1 funke <code>auto_cache_credentials</code>, pak se p\u0159i ka\u017ed\u00e9m autorizovan\u00e9m po\u017eadavku na server obnovuje <code>access_token</code> i <code>refresh_token</code> a tyto se automaticky ukl\u00e1daj\u00ed do zvolen\u00e9ho souboru.</p>"},{"location":"bakalari/schools/","title":"T\u0159\u00edda Schools","text":"<p>T\u0159\u00edda Schools je ur\u010dena pro uchov\u00e1n\u00ed seznamu \u0161kol a jejich URL pro Bakalari API.</p> <p>Umo\u017e\u0148uje vyhledat \u0161kolu/y</p> <ul> <li>podle jm\u00e9na \u0161koly nebo \u010d\u00e1sti jm\u00e9na \u0161koly</li> <li>vyhled\u00e1 \u0161koly podle m\u011bsta</li> <li>lze hledat i podle URL endpointu</li> </ul> <p>Pozn\u00e1mka</p> <p>T\u0159\u00edda Schools uchov\u00e1v\u00e1 polo\u017eky v seznamu <code>Schools.school_list</code> jako instance t\u0159\u00eddy <code>Schools</code></p> <pre><code>@dataclass\nclass School:\n    \"\"\"Data structure for one school item.\"\"\"\n\n    name: str = None\n    api_point: str = None\n    town: str = None\n</code></pre>"},{"location":"bakalari/schools/#metody-tridy-schools","title":"Metody t\u0159\u00eddy <code>Schools</code>","text":""},{"location":"bakalari/schools/#append_school","title":"append_school","text":"<p><pre><code>    def append_school(self, name: str, api_point: str, town: str) -&gt; bool: \n</code></pre> Slou\u017e\u00ed k jednoduch\u00e9mu p\u0159id\u00e1n\u00ed nov\u00e9 \u0161koly do seznamu \u0161kol. V\u0161echny argumeny jsou povinn\u00e9 a nesm\u00ed b\u00fdt <code>None</code> nebo pr\u00e1zdn\u00fd \u0159et\u011bzec.</p> <p>Vrac\u00ed <code>True</code> nebo <code>False</code></p>"},{"location":"bakalari/schools/#get_url","title":"get_url","text":"<p><pre><code>    def get_url(self, name: str | None = None, idx: int | None = None) -&gt; str | False:\n        \"\"\"Return url of school from name or index in dictionary.\n\n        Only one must be specified - name or index, otherwise returns False\n        If name or index is not found in dictionary returns False.\n        \"\"\"\n</code></pre> Vrac\u00ed URL pro \u0161kolu podle jm\u00e9na, \u010d\u00e1sti jm\u00e9na (\u010d\u00e1st jm\u00e9na mus\u00ed b\u00fdt jedine\u010dn\u00e1) nebo indexu ve slovn\u00edku.</p> <p>Vrac\u00ed URL \u0161koly pokud \u0161kola exituje, jinak <code>False</code></p>"},{"location":"bakalari/schools/#get_schools_by_town","title":"get_schools_by_town","text":"<pre><code>    get_schools_by_town(self, town: str | None = None) -&gt; list[School]\n</code></pre> <p>Vrac\u00ed seznam \u0161kol v dan\u00e9m m\u011bst\u011b.</p> <p>Vrac\u00ed <code>list[School]</code> nebo <code>None</code> pokud m\u011bsto neexituje.</p>"},{"location":"bakalari/schools/#get_school_name_by_api_point","title":"get_school_name_by_api_point","text":"<pre><code>    def get_school_name_by_api_point(self, api_point: str) -&gt; str | bool\n</code></pre> <p>Vrac\u00ed n\u00e1zev \u0161koly podle jej\u00edho API.</p>"},{"location":"bakalari/schools/#save_to_file","title":"save_to_file","text":"<pre><code>    def save_to_file(self, filename: str) -&gt; bool\n</code></pre> <p>Ukl\u00e1d\u00e1 na\u010dten\u00fd seznam \u0161kol do souboru ve form\u00e1tu JSON.</p> <p>P\u0159i chyb\u011b parsov\u00e1n\u00ed JSON nebo chyb\u011b z\u00e1pisu vrac\u00ed <code>False</code>, jinak <code>True</code></p>"},{"location":"bakalari/schools/#load_from_file","title":"load_from_file","text":"<pre><code>    def load_from_file(self, filename: str) -&gt; Schools\n</code></pre> <p>Na\u010dte seznam \u0161kol ze souboru v JSON form\u00e1tu.</p> <p>Vrac\u00ed <code>Schools</code> s na\u010dten\u00fdmi \u0161kolami, p\u0159i chyb\u011b parsov\u00e1n\u00ed JSON nebo chyb\u011b otev\u0159en\u00ed souboru vrac\u00ed <code>False</code></p>"},{"location":"bakalari/seznam_skol/","title":"Seznam \u0161kol","text":"<p>Seznam \u0161kol je v modulu <code>async_bakalari_api.datastructure</code></p> <pre><code>async def schools_list(self) -&gt; Schools:\n</code></pre> <p>Omezen\u00ed dotaz\u016f</p> <p>Seznam \u0161kol je pom\u011brn\u011b dlouh\u00fd: 3105 \u0161kol v 1208 m\u011bstech, tedy i 1208 dotaz\u016f na server Bakal\u00e1\u0159\u016f.</p> <p>Nen\u00ed tak vhodn\u00e9 stahovat cel\u00fd seznam p\u0159i ka\u017ed\u00e9m na\u010dten\u00ed modulu. Seznam \u0161kol je ke\u0161ovateln\u00fd pomoc\u00ed metod <code>save_to_file</code> a <code>load_from_file</code></p> <p>Dal\u0161\u00ed mo\u017enost\u00ed, jak omezit po\u010det dotaz\u016f je pou\u017eit\u00ed parametru <code>town</code> p\u0159i vol\u00e1n\u00ed funkce</p> <pre><code>schools: Schools = bakalari.school_list(town=\"po\u017eadovan\u00e9 m\u011bsto\")\n</code></pre> <p>P\u0159i \u00fasp\u011b\u0161n\u00e9m sta\u017een\u00ed vrac\u00ed <code>Schools</code>, pokdu seznam nelze st\u00e1hnout, vrac\u00ed <code>None</code></p> <p>V\u00edce o t\u0159\u00edd\u011b <code>Schools</code></p> <p>P\u0159\u00edklad pou\u017eit\u00ed</p> CLINa\u010dten\u00ed \u0161kol ze serveruNa\u010dten\u00ed ze souboruPou\u017eit\u00ed s Bakalari <pre><code># ulo\u017een\u00ed cel\u00e9ho seznamu \u0161kol do souboru\nbakalari -N schools -s \"skoly.json\"\n\n#vyps\u00e1n\u00ed \u0161kol z ur\u010dit\u00e9ho m\u011bsta\nbakalari -N -t \"m\u011bsto\" schools -l\n</code></pre> <pre><code>from async_bakalari_api import Bakalari\n\nseznam_skol = await Bakalari().schools_list()\n</code></pre> <pre><code>from async_bakalari_api.datastructure import Schools\n\nschools: Schools = await Schools().load_from_file(\"skoly.json\")\n</code></pre> <pre><code>from async_bakalari_api import Bakalari\nfrom async_bakalari_api.datastructure import Schools\n\nschools: Schools = await Schools().load_from_file(\"schools_data.json\")\nbakalari = Bakalari(schools.get_url(\"Jm\u00e9no \u0161koly/\u010d\u00e1st jm\u00e9na \u0161koly\"))\n</code></pre>"},{"location":"cli/","title":"CLI (Command Line Interface)","text":""},{"location":"komens/","title":"Modul Komens","text":"<p>Tento modul slou\u017e\u00ed k z\u00edsk\u00e1n\u00ed p\u0159ijat\u00fdch zpr\u00e1v ze serveru \u0161koly. Tento modul ji\u017e prov\u00e1d\u00ed autorizovan\u00e9 dotazy, tak\u017ee je nutn\u00e9 ji\u017e m\u00edt \u00fadaje o tokenech, p\u0159\u00edpadn\u011b prov\u00e9st prvn\u00ed p\u0159ihl\u00e1\u0161en\u00ed.</p> <pre><code>    class Komens:\n    \"\"\"Class for working with Komens messages.\"\"\"\n\n    def __init__(self, bakalari: Bakalari):\n        \"\"\"Initialize class Komens.\"\"\"\n        self.bakalari = bakalari\n        self.messages = Messages()\n</code></pre> <p>Jako jedin\u00fd parametr p\u0159ij\u00edm\u00e1 inicializovanou instanci <code>Bakalari</code></p> <pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n\n    komens = Komens(bakalari)\n</code></pre>"},{"location":"komens/#nacteni-prijatych-zprav","title":"Na\u010dten\u00ed p\u0159ijat\u00fdch zpr\u00e1v","text":"<p>Na\u010dten\u00ed zpr\u00e1v prob\u00edh\u00e1 metodou <code>Komens.fetch_messages()</code></p> <p>Tato metoda vr\u00e1t\u00ed v\u0161echny zpr\u00e1vy, kter\u00e9 jsou ulo\u017een\u00e9 na serveru \u0161koly a ukl\u00e1d\u00e1 je do t\u0159\u00eddy <code>Messages</code>, kde ka\u017ed\u00e1 zpr\u00e1va je ulo\u017eena jako <code>MessageContainer</code>.</p> <pre><code>Messages = list[MessageContainer]\n</code></pre> <p>Messages</p> <p>ke zpr\u00e1v\u00e1m lze p\u0159istupovat z prom\u011bnn\u00e9 <code>Komens.messages</code></p> <p>V\u00edce o <code>Messages</code> a <code>MessageContainer</code> bude k dispozici Dev dokumentaci pozd\u011bji. Pro u\u017eit\u00ed v b\u011b\u017en\u00e9m re\u017eimu nen\u00ed t\u0159eba se jimi zab\u00fdvat do hloubky.</p> Na\u010dten\u00ed zpr\u00e1v se serveru<pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n\n    komens = Komens(bakalari)\n    await komens.fetch_messages()\n</code></pre>"},{"location":"komens/cteni_zprav/","title":"\u010cten\u00ed p\u0159ijat\u00fdch zpr\u00e1v","text":"<p>Pokud ji\u017e m\u00e1me zpr\u00e1vy sta\u017eeny ze serveru, jsou ulo\u017eeny v <code>Komens.messages</code>, kter\u00fd p\u0159edstavuje seznam zpr\u00e1v ve form\u00e1tu <code>Messages</code>. Ka\u017ed\u00e1 zpr\u00e1va je reprezentov\u00e1na jako <code>MessageContainer</code></p>"},{"location":"komens/cteni_zprav/#celkovy-pocet-prijatych-zprav","title":"Celkov\u00fd po\u010det p\u0159ijat\u00fdch zpr\u00e1v","text":"<pre><code>    Komens.messages.count_messages()\n</code></pre> <p>Vrac\u00ed <code>int</code> jako celkov\u00fd po\u010det zpr\u00e1v</p>"},{"location":"komens/cteni_zprav/#zprava-podle-data-rozsahu-dat","title":"Zpr\u00e1va podle data / rozsahu dat","text":"<p>Pokud chceme zobrazit zpr\u00e1vy jen z ur\u010dit\u00e9ho dne nebo rozsahu dn\u00ed, pak k tomu slou\u017e\u00ed metoda <code>get_messages_by_date()</code></p> <pre><code>    def get_messages_by_date(\n        self, date: dt, to_date: dt | None = None\n    ) -&gt; list[MessageContainer]:\n        \"\"\"Get messages by date.\n\n        If `to_date` is set, then returns list of range from `date` to `to_date`\n        \"\"\"\n</code></pre> DenRozsah dn\u00ed <pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n    from datetime import datetime as dt\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n\n    komens = Komens(bakalari)\n    await komens.get_messages()\n\n    zpravy_ze_dne = komens.messages.get_messages_by_date(dt.date.today())\n    print(msg for msg in zpravy_ze_dne, end=\"\\n --- \\n\")\n</code></pre> Zpr\u00e1vy za posledn\u00edch 30 dn\u00ed<pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n    import datetime\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n\n    komens = Komens(bakalari)\n    await komens.get_messages()\n\n    zpravy_ze_dne = komens.messages.get_messages_by_date(\n            datetime.date.today() + datetime.timedelta(days=-30),\n            to_date=datetime.date.today()\n        )\n    print(msg for msg in zpravy_ze_dne)\n</code></pre>"},{"location":"komens/cteni_zprav/#zprava-podle-id_zpravy","title":"Zpr\u00e1va podle ID_zpr\u00e1vy","text":"<p>Pokud chceme p\u0159e\u010d\u00edst konkr\u00e9tn\u00ed zpr\u00e1vu s <code>ID_zpr\u00e1vy</code> slou\u017e\u00ed k tomu metoda <code>get_message_by_id</code></p> <pre><code>    def get_message_by_id(self, id: str) -&gt; MessageContainer\n</code></pre> PyCLI <pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n\n    komens = Komens(bakalari)\n    await komens.get_messages()\n\n    zprava = komens.messages.get_messages_by_id(1)\n    print(zprava)\n</code></pre> <pre><code># p\u0159ihl\u00e1\u0161en\u00ed pomoc\u00ed token\u016f (-C) ze souboru credentials.json (-cf)\n# \u0161koly na\u010dti ze souboru skoly.json (-sf)\n# a z komens na\u010dti zpr\u00e1vy (--messages) a vypi\u0161 zpr\u00e1vu s ID 1 (-e 1)\n\nbaklari -C -cf credntials.json -sf skoly.json komens --messages -e 1\n</code></pre>"},{"location":"komens/stazeni_prilohy/","title":"Sta\u017een\u00ed p\u0159\u00edlohy zpr\u00e1vy","text":"<p>Zpr\u00e1vy v Komens mohou obsahovat p\u0159\u00edlohy, kter\u00e9 maj\u00ed sv\u00e9 <code>ID</code>. Sta\u017een\u00ed p\u0159\u00edlohy je mo\u017en\u00e9 p\u0159\u00edkazem <code>Komens.get_attachment</code></p> <pre><code>    async def get_attachment(self, id: str) -&gt; Any:\n</code></pre> <p>Vrac\u00ed [filename, filedata]</p> <p>P\u0159i chyb\u011b vrac\u00ed False</p> PyCLI P\u0159\u00edklad ulo\u017een\u00ed p\u0159\u00edlohy do souboru.<pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n    komens = Komens(bakalari)\n\n    data = await komens.get_attachment(\"ID_zpr\u00e1vy\")\n\n    with open(data[0], \"wb\") as fi:\n        fi.write(data[1])\n</code></pre> <pre><code># p\u0159ihla\u0161 se automaticky pomoc\u00ed token\u016f (--autocache)\n# na\u010dti \u0161koly ze souboru skoly.json (-sf)\n# z komens st\u00e1hni zpr\u00e1vy (--messages)\n# ulo\u017e p\u0159\u00edlohu s ID p\u0159\u00edlohy 1\n\nbakalari --auto_cache credentials.json -sf skoly.json komens --messages --attachment 1\n</code></pre>"}]}