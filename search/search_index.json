{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"async Bakal\u00e1\u0159i API v3","text":"<p>Upozorn\u011bn\u00ed</p> <p>Tato API je st\u00e1le vyv\u00edjena, a proto podporuje jen mal\u00e9 mno\u017estv\u00ed endpoint\u016f. Nicm\u00e9n\u011b moduly zve\u0159ejn\u011bn v t\u00e9to dokumentaci jsou ji\u017e stabiln\u00ed.</p> <p><code>async Bakal\u00e1\u0159i API v3</code> je asynchronn\u00ed klient pro komunikaci se \u0161kolami, kter\u00e9 jsou zapojeny do programu Bakal\u00e1\u0159i. Seznam v\u0161ech \u0161kol zapojen\u00fdch do programu Bakal\u00e1\u0159i lze z\u00edskat t\u00e9\u017e z tohoto modulu.</p>"},{"location":"#instalace","title":"Instalace","text":"<p>Modul lze nainstalovat jako bal\u00ed\u010dek z PyPI nebo st\u00e1hnout z GitHubu.</p> <p>Minim\u00e1ln\u00ed verze Pythonu pro tento bal\u00ed\u010dek je 3.12</p>  PyPI GitHub <pre><code>python3 -m pip install async_bakalari_api\n</code></pre> <pre><code>python3 -m pip install \"git+https://github.com/schizza/async-bakalari-api3.git#egg=async-bakalari-api\"\n</code></pre>"},{"location":"bakalari/","title":"modul Bakalari","text":"<p>Z\u00e1kladn\u00ed modul <code>Bakalari</code> se star\u00e1 o komunikaci endpoint\u016f se serverem \u0161koly. Udr\u017euje <code>Credentials</code>, prov\u00e1d\u00ed prvn\u00ed p\u0159ihl\u00e1\u0161en\u00ed a umo\u017e\u0148uje st\u00e1hnout platn\u00fd seznam \u0161kol, ke kter\u00fdm se lze p\u0159ipojit.</p>"},{"location":"bakalari/#trida-bakalari","title":"t\u0159\u00edda Bakalari","text":"class Bakalari<pre><code>class Bakalari (self, \n    server = str | None = None, \n    auto_cache_credentials: bool = False, \n    cache_filename: str | None = None):\n</code></pre> <p>Jako argumenty t\u0159\u00edda p\u0159ij\u00edm\u00e1:</p> <ul> <li>server (str): adresa serveru \u0161koly, se kterou chceme komunikovat</li> <li>auto_cache_credentials (bool, optional): umo\u017e\u0148uje automatick\u00e9 ukl\u00e1d\u00e1n\u00ed <code>access_tokenu</code> a <code>refresh_tokenu</code> do souboru a jejich mo\u017en\u00e9 op\u011btovn\u00e9 pou\u017eit\u00ed p\u0159i dal\u0161\u00edm b\u011bhu programu</li> <li>cache_filename (str, optional): pokud je nastaveno automatick\u00e9 ukl\u00e1d\u00e1n\u00ed token\u016f, pak je nutn\u00e9 zadat i jm\u00e9no souboru, kam se maj\u00ed tokeny ukl\u00e1dat.</li> </ul> <p>Exception</p> <p>t\u0159\u00edda vrac\u00ed chybu <code>Ex.CacheError</code>, pokud je povoleno automatick\u00e9 ukl\u00e1d\u00e1n\u00ed <code>Credentials</code> a nen\u00ed vypln\u011bn\u00e9 <code>cache_filename</code></p>"},{"location":"bakalari/#inicializace-tridy","title":"Inicializace t\u0159\u00eddy","text":"<p>T\u0159\u00eddu lze inicializovat bez zad\u00e1n\u00ed parametr\u016f jako je <code>server</code>, nicm\u00e9n\u011b, pak lze stahovat jen seznam \u0161kol, pop\u0159\u00edpad\u011b zad\u00e1vat neautorizovan\u00e9 dotazy p\u0159\u00edmo na server <code>bakalari.cz</code></p> <p>Inicializace t\u0159\u00eddy Bakalari</p> s ke\u0161ov\u00e1n\u00edmbez ke\u0161ov\u00e1n\u00ed <pre><code>from async_bakalari_api import Bakalari\n\nbakalari = Bakalari(\"http://server_skoly.cz\",\n    auto_cache_credentials=True,\n    cache_filename=\"credentials_cache.json\")\n</code></pre> <pre><code>from async_bakalari_api import Bakalari\n\nbakalari = Bakalari(\"http://server_skoly.cz\")\n</code></pre>"},{"location":"bakalari/credentials/","title":"Credentials","text":"<p>Samotn\u00e9 tokeny i s <code>username</code> i <code>user_id</code> lze spravovat p\u0159es prom\u011bnou <code>Bakalari.credentials</code></p> <p>Heslo se do ke\u0161ovac\u00edho souboru neukl\u00e1d\u00e1, nen\u00ed dostupn\u00e9 ani v prom\u011bnn\u00e9 <code>credentials</code></p> <p>Poj\u010fme se kouknout na t\u0159\u00eddu <code>Credentials</code>, kter\u00e1 se nach\u00e1z\u00ed v <code>async_bakalari_api.datastructure</code></p> class Credentials <pre><code>    @dataclass\n    class Credentials:\n        \"\"\"Credentials holder.\"\"\"\n\n        username: str = None\n        access_token: str = None\n        refresh_token: str = None\n        user_id: str = None\n\n        @classmethod\n        def create(cls, data: dict[str, Any]) -&gt; Credentials:\n            ...\n\n        @classmethod\n        def create_from_json(cls, data: dict[str, Any]) -&gt; Credentials:\n            \"\"\"Return class object from JSON dictionary.\"\"\"\n            ...\n</code></pre> <p>P\u0159istupovat k aktu\u00e1ln\u00edm dat\u016fm lze z instance <code>Bakalari</code></p> <pre><code>    username = Bakalari.credentials.name\n    access_token = Bakalari.credentials.access_token\n    refresh_toke = Bakalari.credentials.refres_token\n    user_id = Bakalari.credentials.user_id\n</code></pre> <p>Zaps\u00e1n\u00ed nov\u00fdch \u00fadaj\u016f lze p\u0159\u00edmo, je ale vhodn\u011bj\u0161\u00ed vyu\u017e\u00edt metodu <code>create</code> nebo <code>create_from_json()</code>. P\u0159i\u010dem\u017e <code>create_from_json()</code> je preferovan\u011bj\u0161\u00ed. </p> <p>U metody <code>create()</code> se p\u0159edpokl\u00e1d\u00e1 datov\u00e9 pole takov\u00e9, kter\u00e9 zas\u00edl\u00e1 p\u0159\u00edmo server:</p> create()create_from_json() <pre><code>    from async_bakalari_api.datastructure import Credentials\n    from async_bakalari_api import Bakalari\n\n    bakalari = Bakalari()\n\n    nove_udaje = {\n        \"bak:UserID\": \"user_id\",\n        \"access_token\": \"nov\u00fd access_token\"\n        \"refresh_token\": \"nov\u00fd refresh_token\",\n        \"username\": \"nov\u00e9 username\"\n    }\n\n    bakalari.credentials = Credentials.create(nove_udaje)\n</code></pre> <pre><code>    from async_bakalari_api.datastructure import Credentials\n    from async_bakalari_api import Bakalari\n\n    bakalari = Bakalari()\n\n    nove_udaje = {\n        \"user_id\": \"nov\u00e9 user_id\n        \"access_token\": \"nov\u00fd access_token\"\n        \"refresh_token\": \"nov\u00fd refresh_token\",\n        \"username\": \"nov\u00e9 username\"\n    }\n\n    bakalari.credentials = Credentials.create_from_json(nove_udaje)\n</code></pre>"},{"location":"bakalari/credentials/#nahrani-ulozenych-udaju","title":"Nahr\u00e1n\u00ed ulo\u017een\u00fdch \u00fadaj\u016f","text":"<p>Jak ji\u017e bylo \u0159e\u010deno, <code>Bakalari</code> umo\u017e\u0148uj\u00ed automatick\u00e9 ukl\u00e1d\u00e1n\u00ed <code>Credentials</code> do souboru ve form\u00e1tu <code>json</code></p> <p>Jejich z\u00edsk\u00e1n\u00ed zp\u011bt je mo\u017en\u00e9 pomoc\u00ed metody <code>load_credentials</code></p> <p>load_credentials(self, filename: str) -&gt; Credentials | bool</p> <p>Jako argument se zad\u00e1v\u00e1 jm\u00e9no souboru. Vrac\u00ed <code>Credentials</code>, kter\u00e9 tak\u00e9 hned ukl\u00e1d\u00e1 do <code>Bakalari.credentials</code></p> <p>P\u0159i ne\u00fasp\u011bchu vrac\u00ed <code>False</code></p> <p>Po zvol\u00e1n\u00ed metody <code>load_credentials</code> m\u00e1me tedy v instanci <code>bakalari</code> aktu\u00e1ln\u00ed \u00fadaje a lze je vyu\u017e\u00edt rovnou p\u0159i p\u0159ihl\u00e1\u0161en\u00ed.</p> <pre><code>    from async_bakalari_api.datastructure import Schools\n    from async_bakalari_api import Bakalari\n\n    school: Schools = await Schools().load_from_file(\"schools_data.json\")\n    bakalari = Bakalari(\n        server=school.get_url(\"\u010d\u00e1st jm\u00e9na \u0161koly\"), \n        auto_cache_credentials=True,\n        cache_file=\"credetials.json\"\n    )\n    bakalari.load_credentials(\"credentials.json\")\n\n    ... nyn\u00ed ji\u017e m\u016f\u017eeme prov\u00e1d\u011bt autorizovan\u00e9 dotazy na server \u0161koly\n</code></pre>"},{"location":"bakalari/first_login/","title":"P\u0159ihl\u00e1\u0161en\u00ed jm\u00e9nem a heslem (prvn\u00ed p\u0159ihl\u00e1\u0161en\u00ed)","text":"<pre><code>async def first_login(self, username: str, password: str) -&gt; Credentials:\n</code></pre> <p>Exceptions</p> <p>Pokud jsou zad\u00e1ny \u0161patn\u00e9 p\u0159\u00edstupov\u00e9 \u00fadaje vyvol\u00e1 funkce v\u00fdjimku <code>Ex.InvalidLogin</code></p> <p>Pro z\u00edsk\u00e1n\u00ed nov\u00e9ho <code>access_tokenu</code> a <code>refresh_tokenu</code> se pou\u017e\u00edv\u00e1 funkce <code>first_login</code>. Tato funkce se takt\u00e9\u017e vol\u00e1 p\u0159i vypr\u0161en\u00ed <code>refresh_tokenu</code>, kdy ji\u017e nelze automaticky z\u00edskat <code>access_token</code>.</p> <p>Zavol\u00e1n\u00edm <code>first_login</code> se <code>Credentials</code> ulo\u017e\u00ed do <code>Bakalari.credentials</code> a z\u00e1rove\u0148 jsou nov\u00e9 p\u0159\u00edstupov\u00e9 \u00fadaje vr\u00e1ceny zp\u011bt, pokud je chcete ukl\u00e1dat n\u011bkam do datab\u00e1ze.</p> <p>Automatick\u00e9 ukl\u00e1d\u00e1n\u00ed p\u0159\u00edstupov\u00fdch \u00fadaj\u016f</p> <p>Pokud je zapnut\u00e1 funke <code>auto_cache_credentials</code>, pak se p\u0159i ka\u017ed\u00e9m autorizovan\u00e9m po\u017eadavku na server obnovuje <code>access_token</code> i <code>refresh_token</code> a tyto se automaticky ukl\u00e1daj\u00ed do zvolen\u00e9ho souboru.</p>"},{"location":"bakalari/seznam_skol/","title":"Seznam \u0161kol","text":"<p>Seznam \u0161kol je pom\u011brn\u011b dlouh\u00fd a nen\u00ed vhodn\u00e9 ho stahovat p\u0159i ka\u017ed\u00e9m na\u010dten\u00ed modulu. Seznam \u0161kol je ke\u0161ovateln\u00fd pomoc\u00ed funkc\u00ed <code>save_to_file</code> a <code>load_from_file</code>, ob\u011b funkce jsou v modulu <code>datastructure</code></p> <pre><code>async def async_schools_list(self) -&gt; Schools:\n</code></pre> <p>P\u0159i \u00fasp\u011b\u0161n\u00e9m sta\u017een\u00ed vrac\u00ed <code>Schools</code>, pokdu seznam nelze st\u00e1hnout, vrac\u00ed <code>None</code></p> <p>V\u00edce o t\u0159\u00edd\u011b <code>Schools</code></p> <p>P\u0159\u00edklad pou\u017eit\u00ed</p> Na\u010dten\u00ed \u0161kol ze serveruNa\u010dten\u00ed ze souboruPou\u017eit\u00ed s Bakalari <pre><code>from async_bakalari_api import Bakalari\n\nseznam_skol = await Bakalari().async_schools_list()\n</code></pre> <pre><code>from async_bakalari_api import Schools\n\nschools: Schools = await Schools().load_from_file(\"schools_data.json\")\n</code></pre> <pre><code>from async_bakalari_api import Bakalari, Schools\n\nschools: Schools = await Schools().load_from_file(\"schools_data.json\")\nbakalari = Bakalari(schools.get_url(\"Jm\u00e9no \u0161koly/\u010d\u00e1st jm\u00e9na \u0161koly\"))\n</code></pre>"},{"location":"komens/","title":"Modul Komens","text":"<p>Tento modul slou\u017e\u00ed k z\u00edsk\u00e1n\u00ed p\u0159ijat\u00fdch zpr\u00e1v ze serveru \u0161koly. Tento modul ji\u017e prov\u00e1d\u00ed autorizovan\u00e9 dotazy, tak\u017ee je nutn\u00e9 ji\u017e m\u00edt \u00fadaje o tokenech, p\u0159\u00edpadn\u011b prov\u00e9st prvn\u00ed p\u0159ihl\u00e1\u0161en\u00ed.</p> <pre><code>    class Komens:\n    \"\"\"Class for working with Komens messages.\"\"\"\n\n    def __init__(self, bakalari: Bakalari):\n        \"\"\"Initialize class Komens.\"\"\"\n        self.bakalari = bakalari\n        self.messages = Messages()\n</code></pre> <p>Jako jedin\u00fd parametr p\u0159ij\u00edm\u00e1 inicializovanou instanci <code>Bakalari</code></p> <pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n\n    komens = Komens(bakalari)\n</code></pre>"},{"location":"komens/#nacteni-prijatych-zprav","title":"Na\u010dten\u00ed p\u0159ijat\u00fdch zpr\u00e1v","text":"<p>Na\u010dten\u00ed zpr\u00e1v prob\u00edh\u00e1 metodou <code>Komens.get_messages()</code></p> <p>Tato metoda vr\u00e1t\u00ed v\u0161echny zpr\u00e1vy, kter\u00e9 jsou ulo\u017een\u00e9 na serveru \u0161koly a ukl\u00e1d\u00e1 je do t\u0159\u00eddy <code>Messages</code>, kde ka\u017ed\u00e1 zpr\u00e1va je ulo\u017eena jako <code>MessageContainer</code>.</p> <pre><code>Messages = list[MessageContainer]\n</code></pre> <p>Messages</p> <p>ke zpr\u00e1v\u00e1m lze p\u0159istupovat z instance <code>Komens.messages</code></p> <p>V\u00edce o <code>Messages</code> a <code>MessageContainer</code> bude k dispozici Dev dokumentaci pozd\u011bji. Pro u\u017eit\u00ed v b\u011b\u017en\u00e9m re\u017eimu nen\u00ed t\u0159eba se jimi zab\u00fdvat do hloubky.</p> Na\u010dten\u00ed zpr\u00e1v se serveru<pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n\n    komens = Komens(bakalari)\n    await komens.get_messages()\n</code></pre>"},{"location":"komens/cteni_zprav/","title":"\u010cten\u00ed p\u0159ijat\u00fdch zpr\u00e1v","text":"<p>Pokud ji\u017e m\u00e1me zpr\u00e1vy sta\u017eeny ze serveru, jsou ulo\u017eeny v <code>Komens.messages</code>, kter\u00fd p\u0159edstavuje seznam zpr\u00e1v ve form\u00e1tu <code>Messages</code>. Ka\u017ed\u00e1 zpr\u00e1va je reprezentov\u00e1na jako <code>MessageContainer</code></p>"},{"location":"komens/cteni_zprav/#celkovy-pocet-prijatych-zprav","title":"Celkov\u00fd po\u010det p\u0159ijat\u00fdch zpr\u00e1v","text":"<pre><code>    Komens.messages.count_messages()\n</code></pre> <p>Vrac\u00ed <code>int</code> jako celkov\u00fd po\u010det zpr\u00e1v</p>"},{"location":"komens/cteni_zprav/#zprava-podle-data-rozsahu-dat","title":"Zpr\u00e1va podle data / rozsahu dat","text":"<p>Pokud chceme zobrazit zpr\u00e1vy jen z ur\u010dit\u00e9ho dne nebo rozsahu dn\u00ed, pak k tomu slou\u017e\u00ed metoda <code>get_messages_by_date()</code></p> <pre><code>    def get_messages_by_date(\n        self, date: dt, to_date: dt | None = None\n    ) -&gt; list[MessageContainer]:\n        \"\"\"Get messages by date.\n\n        If `to_date` is set, then returns list of range from `date` to `to_date`\n        \"\"\"\n</code></pre> DenRozsah dn\u00ed <pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n    from datetime import datetime as dt\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n\n    komens = Komens(bakalari)\n    await komens.get_messages()\n\n    zpravy_ze_dne = komens.messages.get_messages_by_date(dt.date.today())\n    for msg in zpravy_ze_dne:\n        print(msg.text)\n</code></pre> Zpr\u00e1vy za posledn\u00edch 30 dn\u00ed<pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n    import datetime\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n\n    komens = Komens(bakalari)\n    await komens.get_messages()\n\n    zpravy_ze_dne = komens.messages.get_messages_by_date(\n            datetime.date.today() + datetime.timedelta(days=-30),\n            to_date=datetime.date.today()\n        )\n    for msg in zpravy_ze_dne:\n        print(msg.text)\n</code></pre>"},{"location":"komens/stazeni_prilohy/","title":"Sta\u017een\u00ed p\u0159\u00edlohy zpr\u00e1vy","text":"<p>Zpr\u00e1vy v Komens mohou obsahovat p\u0159\u00edlohy, kter\u00e9 maj\u00ed sv\u00e9 <code>ID</code>. Sta\u017een\u00ed p\u0159\u00edlohy je mo\u017en\u00e9 p\u0159\u00edkazem <code>Komens.get_attachment</code></p> <pre><code>    async def get_attachment(self, id: str) -&gt; Any:\n</code></pre> <p>Vrac\u00ed [filename, filedata]</p> <p>P\u0159i chyb\u011b vrac\u00ed False</p> P\u0159\u00edklad ulo\u017een\u00ed p\u0159\u00edlohy do souboru.<pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n    komens = Komens(bakalari)\n\n    data = await komens.get_attachment(\"ID_zpr\u00e1vy\")\n\n    with open(data[0], \"wb\") as fi:\n        fi.write(data[1])\n        fi.close()\n</code></pre>"}]}