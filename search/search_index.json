{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"async Bakal\u00e1\u0159i API v3","text":"<p>Upozorn\u011bn\u00ed</p> <p>Toto API je st\u00e1le vyv\u00edjeno, a proto podporuje jen mal\u00e9 mno\u017estv\u00ed endpoint\u016f. Nicm\u00e9n\u011b moduly zve\u0159ejn\u011bn\u00e9 v t\u00e9to dokumentaci jsou ji\u017e stabiln\u00ed.</p> <p><code>async Bakal\u00e1\u0159i API v3</code> je asynchronn\u00ed klient pro komunikaci se \u0161kolami, kter\u00e9 jsou zapojeny do programu Bakal\u00e1\u0159i. Aplikace je naps\u00e1na kompletn\u011b v Pythonu.</p> <p>M\u00e1 takt\u00e9\u017e zabudovan\u00fd modul pro p\u0159\u00edkazovou \u0159\u00e1dku <code>CLI</code> k jednoduch\u00e9mu pou\u017eit\u00ed.</p> <p>Seznam v\u0161ech \u0161kol zapojen\u00fdch do programu Bakal\u00e1\u0159i lze z\u00edskat t\u00e9\u017e z tohoto modulu.</p>"},{"location":"#prehled-modulu","title":"P\u0159ehled modul\u016f","text":"<ul> <li>Bakalari \u2013 z\u00e1kladn\u00ed klient</li> <li>Komens \u2013 zpr\u00e1vy (p\u0159\u00edchoz\u00ed, p\u0159\u00edlohy)</li> <li>Marks \u2013 zn\u00e1mky a statistiky</li> <li>Timetable \u2013 rozvrh (aktu\u00e1ln\u00ed i st\u00e1l\u00fd)</li> </ul>"},{"location":"#instalace","title":"Instalace","text":"<p>Modul lze nainstalovat jako bal\u00ed\u010dek z PyPI nebo st\u00e1hnout z GitHubu.</p> <p>Minim\u00e1ln\u00ed verze Pythonu pro tento bal\u00ed\u010dek je 3.12</p>  PyPI GitHub <pre><code>python3 -m pip install async_bakalari_api\n</code></pre> <pre><code>python3 -m pip install \"git+https://github.com/schizza/async-bakalari-api3.git#egg=async-bakalari-api\"\n</code></pre> <p>CLI</p> <p>Po instalaci bal\u00ed\u010dku je dostupn\u00e9 jednoduch\u00e9 CLI - <code>bakalari</code></p>"},{"location":"#prakticky-pruvodce-workflow","title":"Praktick\u00fd pr\u016fvodce (workflow)","text":"<ul> <li> <p>Krok 1: Z\u00edsk\u00e1n\u00ed seznamu \u0161kol   <pre><code>from async_bakalari_api import Bakalari\nfrom async_bakalari_api.datastructure import Schools\n\n# Na\u010dten\u00ed ze serveru (doporu\u010deno omezit m\u011bstem a v\u00fdsledek ulo\u017eit)\nbakalari = Bakalari()\nschools = await bakalari.schools_list(town=\"Praha\", recursive=False)\nif schools:\n    await schools.save_to_file(\"schools.json\")\n\n# nebo na\u010dten\u00ed ze souboru\nschools = await Schools().load_from_file(\"schools.json\")\nserver = schools.get_url(\"\u010c\u00e1st n\u00e1zvu \u0161koly\")\n</code></pre></p> </li> <li> <p>Krok 2: P\u0159ihl\u00e1\u0161en\u00ed a tokeny   <pre><code>from async_bakalari_api import Bakalari\n\n# Prvn\u00ed p\u0159ihl\u00e1\u0161en\u00ed a automatick\u00e9 ukl\u00e1d\u00e1n\u00ed token\u016f\nbakalari = Bakalari(server=server, auto_cache_credentials=True, cache_filename=\"credentials.json\")\nasync with bakalari:\n    await bakalari.first_login(\"USERNAME\", \"PASSWORD\")\n\n# Dal\u0161\u00ed b\u011bhy s automatick\u00fdm na\u010dten\u00edm token\u016f\nbakalari = Bakalari(server=server, auto_cache_credentials=True, cache_filename=\"credentials.json\")\nbakalari.load_credentials(\"credentials.json\")\nasync with bakalari:\n    # autorizovan\u00e9 vol\u00e1n\u00ed...\n    pass\n</code></pre></p> </li> <li> <p>Krok 3: Pou\u017eit\u00ed modul\u016f</p> </li> <li>Komens (zpr\u00e1vy)     <pre><code>from async_bakalari_api.komens import Komens\n\nkomens = Komens(bakalari)\nmessages = await komens.fetch_messages()\nunread = await komens.get_unread_messages()\n</code></pre></li> <li>Marks (zn\u00e1mky)     <pre><code>from async_bakalari_api.marks import Marks\n\nmarks = Marks(bakalari)\nawait marks.fetch_marks()\nsummary = await marks.get_all_marks_summary()\n</code></pre></li> <li>Timetable (rozvrh)     <pre><code>from async_bakalari_api.timetable import Timetable, TimetableContext\n\ntt = Timetable(bakalari)\nweek = await tt.fetch_actual(context=TimetableContext(kind=\"class\", id=\"1.A\"))\nprint(week.format_week())\n</code></pre></li> </ul>"},{"location":"#logovani","title":"Logov\u00e1n\u00ed","text":"<p>Knihovna poskytuje jednoduchou konfiguraci logov\u00e1n\u00ed s roz\u0161\u00ed\u0159en\u00fdmi poli (event, url, method, latency_ms, retries, status, error).</p> <pre><code>from async_bakalari_api import configure_logging\nimport logging\n\n# Podrobn\u00e9 logy\nconfigure_logging(logging.DEBUG)\n\n# nebo pouze chyby\nconfigure_logging(logging.ERROR)\n</code></pre> <ul> <li>Alternativn\u011b lze \u00farove\u0148 \u0159\u00eddit prom\u011bnnou prost\u0159ed\u00ed:</li> <li>BAKALARI_LOG_LEVEL=DEBUG|INFO|WARNING|ERROR</li> <li>Logy jsou strukturovan\u00e9 a barevn\u00e9 (pro snaz\u0161\u00ed \u010dten\u00ed v termin\u00e1lu).</li> </ul>"},{"location":"#vyjimky-exceptions","title":"V\u00fdjimky (Exceptions)","text":"<p>B\u011b\u017en\u00e9 dom\u00e9nov\u00e9 chyby vystavuje jmenn\u00fd prostor <code>Ex</code>:</p> <ul> <li>Ex.InvalidLogin \u2013 neplatn\u00e9 p\u0159ihla\u0161ovac\u00ed \u00fadaje</li> <li>Ex.AccessTokenExpired \u2013 vypr\u0161el access token (prob\u011bhne auto-refresh)</li> <li>Ex.RefreshTokenExpired \u2013 vypr\u0161el/nen\u00ed platn\u00fd refresh token (vy\u017eaduje znovu first_login)</li> <li>Ex.InvalidToken \u2013 neplatn\u00fd token</li> <li>Ex.InvalidRefreshToken \u2013 neplatn\u00fd refresh token</li> <li>Ex.RefreshTokenRedeemd \u2013 refresh token byl ji\u017e uplatn\u011bn</li> <li>Ex.TokenMissing \u2013 chyb\u00ed access/refresh token</li> <li>Ex.BadRequestException \u2013 obecn\u00e1 chyba po\u017eadavku (4xx/5xx, nespr\u00e1vn\u00e9 parametry apod.)</li> <li>Ex.InvalidHTTPMethod \u2013 endpoint nepodporuje metodu</li> <li>Ex.TimeoutException \u2013 vypr\u0161el timeout po\u017eadavku</li> <li>Ex.BadEndpointUrl \u2013 \u0161patn\u011b slo\u017een\u00e1 URL (nap\u0159. chyb\u011bj\u00edc\u00ed server)</li> <li>Ex.InvalidCredentials, Ex.InvalidResponse, Ex.TokensExpired, Ex.CacheError \u2013 ostatn\u00ed stavy</li> </ul> <p>Uk\u00e1zka o\u0161et\u0159en\u00ed chyb p\u0159i vol\u00e1n\u00ed API: <pre><code>from async_bakalari_api import Bakalari\nfrom async_bakalari_api.const import EndPoint\nfrom async_bakalari_api.exceptions import Ex\n\nbakalari = Bakalari(server=\"https://server_skoly\")\n\ntry:\n    async with bakalari:\n        resp = await bakalari.send_auth_request(EndPoint.MARKS)\nexcept Ex.AccessTokenExpired:\n    # Obvykle se provede automatick\u00fd refresh, sem se dostanete, pokud obnovu nelze prov\u00e9st.\n    await bakalari.refresh_access_token()\nexcept Ex.RefreshTokenExpired:\n    # Nelze obnovit \u2013 je nutn\u00e9 p\u0159ihl\u00e1\u0161en\u00ed jm\u00e9nem a heslem\n    await bakalari.first_login(\"USERNAME\", \"PASSWORD\")\nexcept Ex.BadRequestException as e:\n    print(f\"Chybn\u00fd po\u017eadavek: {e}\")\n</code></pre></p>"},{"location":"podrobna_instalace/","title":"Podrobn\u00e1 instalace","text":"<p>Aplikace je kompletn\u011b naps\u00e1na v <code>Pythonu</code> verze 3.12</p> <p>Jak naistalovat Python p\u0159esahuje tuto dokumentaci, ale jednoduch\u00e9 postupy jsou k dispozici nap\u0159\u00edkalad zde.</p>"},{"location":"podrobna_instalace/#nove-virtualni-prostredi","title":"Nov\u00e9 virtu\u00e1ln\u00ed prost\u0159ed\u00ed","text":"<p>Pokud m\u00e1te ji\u017e nainstalovan\u00fd Python vytvo\u0159te nov\u00e9 virtu\u00e1ln\u00ed prost\u0159edn\u00ed ve slo\u017ece, kde chcete pracovat s <code>async_bakalari_api</code></p> Mac/LinuxWindows <pre><code>mkdir ~/bakalari_test\ncd ~/bakalari_test\n\npython3 -m venv .venv\n</code></pre> <pre><code>mkdir bakalari_test\ncd bakalari_test\n\npy -3 -m venv venv\n</code></pre> <p>Virtu\u00e1ln\u00ed prost\u0159ed\u00ed se mus\u00ed v\u017edy p\u0159ed pou\u017eit\u00edm aktivovat.</p> Mac/LinuxWindows <pre><code>source .venv/bin/acitvate\n</code></pre> <pre><code>venv\\Scripts\\activate\n</code></pre> <p>Po aktivaci virtu\u00e1ln\u00edho prost\u0159ed\u00ed se ji\u017e p\u0159\u00edkazy nem\u011bn\u00ed v z\u00e1vislosti na syst\u00e9mu.</p> Instalace bal\u00ed\u010dku `async_bakalari_api`<pre><code>python3 -m pip install async_bakalari_api\n</code></pre> <p>Nyn\u00ed ji\u017e m\u016f\u017eete vyu\u017e\u00edvat <code>CLI</code></p>"},{"location":"bakalari/","title":"modul Bakalari","text":""},{"location":"bakalari/#autorizovane-pozadavky-send_auth_request","title":"Autorizovan\u00e9 po\u017eadavky (send_auth_request)","text":"<pre><code>async def send_auth_request(self, request_endpoint: EndPoint, extend: str | None = None, **kwargs) -&gt; Any:\n</code></pre> <ul> <li>Parametry:</li> <li><code>request_endpoint (EndPoint)</code>: c\u00edlov\u00fd endpoint. HTTP metoda se odvozuje z definice endpointu (<code>get</code>/<code>post</code>).</li> <li><code>extend (str | None)</code>: voliteln\u00fd p\u0159\u00edlepek na konec URL (nap\u0159. <code>\"/{id}\"</code> pro sta\u017een\u00ed p\u0159\u00edlohy).</li> <li> <p><code>**kwargs</code>: voliteln\u00e9 argumenty pro HTTP po\u017eadavek (nap\u0159. <code>params=...</code>, <code>data=...</code>, <code>json=...</code>).</p> </li> <li> <p>Chov\u00e1n\u00ed:</p> </li> <li>Provede autorizovan\u00fd po\u017eadavek s vyu\u017eit\u00edm <code>access_token</code>. Pokud je token neplatn\u00fd/expiruje, prob\u011bhne automatick\u00fd refresh p\u0159es <code>refresh_access_token()</code> a po\u017eadavek se zopakuje (1 pokus).</li> <li>Hlavi\u010dka <code>Authorization: Bearer &lt;access_token&gt;</code> je nastavena automaticky.</li> <li> <p>N\u00e1vratov\u00e1 hodnota je surov\u00e1 odpov\u011b\u010f serveru:</p> <ul> <li>b\u011b\u017en\u011b JSON (dict/list),</li> <li>pro bin\u00e1rn\u00ed soubory (nap\u0159. p\u0159\u00edloha v Komens) dvojice <code>[filename, filedata]</code>.</li> </ul> </li> <li> <p>V\u00fdjimky:</p> </li> <li><code>Ex.TokenMissing</code> (chyb\u00ed p\u0159\u00edstupov\u00e9 tokeny),</li> <li><code>Ex.AccessTokenExpired</code>, <code>Ex.InvalidToken</code> (neplatn\u00fd/expiruj\u00edc\u00ed p\u0159\u00edstupov\u00fd token),</li> <li><code>Ex.RefreshTokenExpired</code> (nen\u00ed mo\u017en\u00e9 obnovit token),</li> <li><code>Ex.BadRequestException</code> (ostatn\u00ed chyby HTTP, 4xx/5xx),</li> <li> <p>p\u0159\u00edpadn\u011b specifick\u00e9 chyby dle <code>error_uri</code> vr\u00e1cen\u00e9 serverem.</p> </li> <li> <p>Pozn\u00e1mka:</p> </li> <li>Pokud endpoint nen\u00ed absolutn\u00ed URL, je slo\u017een ze <code>server</code> + <code>endpoint</code>. Metoda vyu\u017e\u00edv\u00e1 vnit\u0159n\u00ed klient s jednotn\u00fdm logov\u00e1n\u00edm a m\u011b\u0159en\u00edm latenc\u00ed.</li> </ul>"},{"location":"bakalari/#neautorizovane-pozadavky-send_unauth_request","title":"Neautorizovan\u00e9 po\u017eadavky (send_unauth_request)","text":"<pre><code>async def send_unauth_request(self, request: EndPoint, headers: dict[str, str] | None = None, **kwargs) -&gt; Any:\n</code></pre> <ul> <li>Parametry:</li> <li><code>request (EndPoint)</code>: c\u00edlov\u00fd endpoint.</li> <li><code>headers (dict[str, str] | None)</code>: voliteln\u00e9 HTTP hlavi\u010dky; pokud nejsou zad\u00e1ny, pou\u017eije se pr\u00e1zdn\u00fd slovn\u00edk.</li> <li> <p><code>**kwargs</code>: voliteln\u00e9 argumenty pro HTTP po\u017eadavek (nap\u0159. <code>params=...</code>, <code>data=...</code>, <code>json=...</code>).</p> </li> <li> <p>Chov\u00e1n\u00ed:</p> </li> <li>Metoda zvol\u00ed HTTP metodu podle endpointu (<code>get</code> \u2192 GET, jinak POST).</li> <li>Pro neautorizovan\u00e9 vol\u00e1n\u00ed (nap\u0159. p\u0159ihl\u00e1\u0161en\u00ed nebo ve\u0159ejn\u00e9 slu\u017eby) \u2013 nep\u0159id\u00e1v\u00e1 hlavi\u010dku <code>Authorization</code>.</li> <li> <p>N\u00e1vratov\u00e1 hodnota je surov\u00e1 odpov\u011b\u010f serveru (typicky JSON). Pro bin\u00e1rn\u00ed odpov\u011bdi vrac\u00ed <code>[filename, filedata]</code>.</p> </li> <li> <p>V\u00fdjimky:</p> </li> <li><code>Ex.InvalidLogin</code> (p\u0159i \u0161patn\u00fdch p\u0159ihla\u0161ovac\u00edch \u00fadaj\u00edch v loginu),</li> <li> <p><code>Ex.BadRequestException</code> (ostatn\u00ed chyby HTTP, 4xx/5xx).</p> </li> <li> <p>P\u0159\u00edklady:</p> </li> <li>P\u0159ihl\u00e1\u0161en\u00ed (form-url-encoded t\u011blo a bez tokenu) nebo vol\u00e1n\u00ed ve\u0159ejn\u00fdch endpoint\u016f Bakal\u00e1\u0159\u016f.</li> </ul>"},{"location":"bakalari/#seznam-skol-schools_list","title":"Seznam \u0161kol (schools_list)","text":"<pre><code>async def schools_list(self, town: str | None = None, recursive: bool = True) -&gt; Schools | None:\n</code></pre> <ul> <li>Parametry:</li> <li><code>town (str | None)</code>: voliteln\u00fd filtr na n\u00e1zev m\u011bsta.</li> <li> <p><code>recursive (bool)</code>: zp\u016fsob filtrov\u00e1n\u00ed podle <code>town</code>:</p> <ul> <li><code>True</code> (v\u00fdchoz\u00ed): vybere m\u011bsta obsahuj\u00edc\u00ed \u0159et\u011bzec <code>town</code> kdekoliv v n\u00e1zvu,</li> <li><code>False</code>: vybere pouze m\u011bsta, jejich\u017e n\u00e1zev za\u010d\u00edn\u00e1 na <code>town</code>.</li> </ul> </li> <li> <p>Chov\u00e1n\u00ed:</p> </li> <li>Nejprve st\u00e1hne seznam m\u011bst z ve\u0159ejn\u00e9ho endpointu Bakal\u00e1\u0159\u016f:<ul> <li><code>https://sluzby.bakalari.cz/api/v1/municipality</code></li> </ul> </li> <li>Pro ka\u017ed\u00e9 (filtrovan\u00e9) m\u011bsto st\u00e1hne seznam \u0161kol a sestav\u00ed objekt <code>Schools</code>.</li> <li>Po\u010det soub\u011b\u017en\u00fdch dotaz\u016f na m\u011bsta je omezen parametrem <code>school_concurrency</code> nastaven\u00fdm v konstruktoru <code>Bakalari</code> (v\u00fdchoz\u00ed 10).</li> <li>P\u0159i \u00fasp\u011bchu:<ul> <li>vrac\u00ed instanci <code>Schools</code>,</li> <li>z\u00e1rove\u0148 ulo\u017e\u00ed v\u00fdsledek do <code>self.schools</code> (vedlej\u0161\u00ed efekt).</li> </ul> </li> <li> <p>P\u0159i chyb\u011b vrac\u00ed <code>None</code>.</p> </li> <li> <p>Pozn\u00e1mky:</p> </li> <li>V\u011bt\u0161\u00ed rozsah m\u016f\u017ee znamenat stovky a\u017e tis\u00edce po\u017eadavk\u016f (podle po\u010dtu m\u011bst); zva\u017ete filtr <code>town</code> nebo ke\u0161ov\u00e1n\u00ed.</li> <li> <p>Objekt <code>Schools</code> lze ulo\u017eit/na\u010d\u00edst ze souboru (viz t\u0159\u00edda Schools):</p> <ul> <li><code>await schools.save_to_file(\"schools.json\")</code></li> <li><code>await Schools().load_from_file(\"schools.json\")</code></li> </ul> </li> <li> <p>P\u0159\u00edklady:   <pre><code>from async_bakalari_api import Bakalari\n\nbakalari = Bakalari()\n# v\u0161echny \u0161koly (doporu\u010deno ukl\u00e1dat do souboru)\nschools = await bakalari.schools_list()\nif schools:\n    await schools.save_to_file(\"schools.json\")\n\n# pouze m\u011bsta za\u010d\u00ednaj\u00edc\u00ed na 'Praha'\nschools = await bakalari.schools_list(town=\"Praha\", recursive=False)\n\n# substring vyhled\u00e1v\u00e1n\u00ed m\u011bst\nschools = await bakalari.schools_list(town=\"Brno\")  # nap\u0159. 'Brno' kdekoliv v n\u00e1zvu m\u011bsta\n</code></pre></p> </li> </ul> <p>Z\u00e1kladn\u00ed modul <code>Bakalari</code> se star\u00e1 o komunikaci endpoint\u016f se serverem \u0161koly. Udr\u017euje <code>Credentials</code>, prov\u00e1d\u00ed prvn\u00ed p\u0159ihl\u00e1\u0161en\u00ed a umo\u017e\u0148uje st\u00e1hnout platn\u00fd seznam \u0161kol, ke kter\u00fdm se lze p\u0159ipojit.</p>"},{"location":"bakalari/#trida-bakalari","title":"t\u0159\u00edda Bakalari","text":"class Bakalari<pre><code>class Bakalari (self,\n    server: str | None = None,\n    credentials: Credentials | None = None,\n    auto_cache_credentials: bool = False,\n    cache_filename: str | None = None,\n    session: aiohttp.ClientSession | None = None,\n    school_concurrency: int = 10,\n):\n</code></pre> <p>Jako argumenty t\u0159\u00edda p\u0159ij\u00edm\u00e1:</p> <ul> <li>server (str | None): adresa serveru \u0161koly, se kterou chceme komunikovat</li> <li>credentials (Credentials | None): voliteln\u00e9 p\u0159ed\u00e1n\u00ed hotov\u00fdch p\u0159ihla\u0161ovac\u00edch \u00fadaj\u016f; pokud nejsou p\u0159ed\u00e1ny, vytvo\u0159\u00ed se pr\u00e1zdn\u00e9 <code>Credentials</code></li> <li>auto_cache_credentials (bool, optional): umo\u017e\u0148uje automatick\u00e9 ukl\u00e1d\u00e1n\u00ed <code>access_tokenu</code> a <code>refresh_tokenu</code> do souboru a jejich mo\u017en\u00e9 op\u011btovn\u00e9 pou\u017eit\u00ed p\u0159i dal\u0161\u00edm b\u011bhu programu</li> <li>cache_filename (str | None, optional): pokud je nastaveno automatick\u00e9 ukl\u00e1d\u00e1n\u00ed token\u016f, pak je nutn\u00e9 zadat i jm\u00e9no souboru, kam se maj\u00ed tokeny ukl\u00e1dat</li> <li>session (aiohttp.ClientSession | None, optional): voliteln\u011b lze p\u0159edat existuj\u00edc\u00ed HTTP session; pokud nen\u00ed zad\u00e1na, klient si spravuje vlastn\u00ed</li> <li>school_concurrency (int, optional): maxim\u00e1ln\u00ed po\u010det soub\u011b\u017en\u00fdch dotaz\u016f na m\u011bsta p\u0159i sestavov\u00e1n\u00ed seznamu \u0161kol; v\u00fdchoz\u00ed hodnota je 10</li> </ul> <p>Exception</p> <p>t\u0159\u00edda vrac\u00ed chybu <code>Ex.CacheError</code>, pokud je povoleno automatick\u00e9 ukl\u00e1d\u00e1n\u00ed <code>Credentials</code> a nen\u00ed vypln\u011bn\u00e9 <code>cache_filename</code></p> <p>Credentials jsou read-only a chov\u00e1n\u00ed auto-cache</p> <p>Vlastnost <code>Bakalari.credentials</code> je pouze pro \u010dten\u00ed. P\u0159\u00edm\u00e9 p\u0159i\u0159azen\u00ed nen\u00ed mo\u017en\u00e9 (vyvol\u00e1 <code>AttributeError</code>). Pro z\u00edsk\u00e1n\u00ed/obnovu token\u016f pou\u017eijte metody jako <code>first_login(...)</code> nebo automatick\u00e9 obnoven\u00ed p\u0159i autorizovan\u00fdch po\u017eadavc\u00edch.</p> <p>Pokud je zapnuto <code>auto_cache_credentials=True</code> a je nastaveno <code>cache_filename</code>, klient se p\u0159i inicializaci pokus\u00ed <code>Credentials</code> automaticky na\u010d\u00edst ze souboru a po ka\u017ed\u00e9m obnoven\u00ed token\u016f je do n\u011bj tak\u00e9 ukl\u00e1d\u00e1.</p>"},{"location":"bakalari/#inicializace-tridy","title":"Inicializace t\u0159\u00eddy","text":"<p>T\u0159\u00eddu lze inicializovat bez zad\u00e1n\u00ed parametr\u016f jako je <code>server</code>, nicm\u00e9n\u011b, pak lze stahovat jen seznam \u0161kol, pop\u0159\u00edpad\u011b zad\u00e1vat neautorizovan\u00e9 dotazy p\u0159\u00edmo na server <code>bakalari.cz</code></p> <p>Inicializace t\u0159\u00eddy Bakalari</p> s ke\u0161ov\u00e1n\u00edmbez ke\u0161ov\u00e1n\u00ed <pre><code>from async_bakalari_api import Bakalari\n\nbakalari = Bakalari(\"http://server_skoly.cz\",\n    auto_cache_credentials=True,\n    cache_filename=\"credentials_cache.json\")\n</code></pre> <pre><code>from async_bakalari_api import Bakalari\n\nbakalari = Bakalari(\"http://server_skoly.cz\")\n</code></pre>"},{"location":"bakalari/credentials/","title":"Credentials","text":"<p>Samotn\u00e9 tokeny i s <code>username</code> i <code>user_id</code> lze spravovat p\u0159es prom\u011bnou <code>Bakalari.credentials</code></p> <p>Heslo se do ke\u0161ovac\u00edho souboru neukl\u00e1d\u00e1, nen\u00ed dostupn\u00e9 ani v prom\u011bnn\u00e9 <code>credentials</code></p> <p>Poj\u010fme se kouknout na t\u0159\u00eddu <code>Credentials</code>, kter\u00e1 se nach\u00e1z\u00ed v <code>async_bakalari_api.datastructure</code></p> class Credentials <pre><code>    @dataclass(frozen=True)\n    class Credentials:\n        \"\"\"Credentials holder.\"\"\"\n\n        username: str | None = None\n        access_token: str | None = None\n        refresh_token: str | None = None\n        user_id: str | None = None\n\n        @classmethod\n        def create(cls, data: dict[str, Any]) -&gt; Credentials:\n            ...\n\n        @classmethod\n        def create_from_json(cls, data: dict[str, Any]) -&gt; Credentials:\n            \"\"\"Return class object from JSON dictionary.\"\"\"\n            ...\n</code></pre> <p>P\u0159istupovat k aktu\u00e1ln\u00edm dat\u016fm lze z instance <code>Bakalari</code></p> <pre><code>    username = bakalari.credentials.username\n    access_token = bakalari.credentials.access_token\n    refresh_token = bakalari.credentials.refresh_token\n    user_id = bakalari.credentials.user_id\n</code></pre> <p>Hodnoty v <code>Bakalari.credentials</code> jsou pouze pro \u010dten\u00ed. Nov\u00e9 \u00fadaje p\u0159ed\u00e1vejte p\u0159i vytvo\u0159en\u00ed instance <code>Bakalari</code> p\u0159es parametr <code>credentials</code>, nebo pou\u017eijte <code>first_login(...)</code> \u010di <code>load_credentials(...)</code>. P\u0159evod dat z payloadu serveru usnad\u0148uj\u00ed metody <code>create</code> a <code>create_from_json()</code> (preferov\u00e1na).</p> <p>U metody <code>create()</code> se p\u0159edpokl\u00e1d\u00e1 datov\u00e9 pole takov\u00e9, kter\u00e9 zas\u00edl\u00e1 p\u0159\u00edmo server:</p> create()create_from_json() <pre><code>    from async_bakalari_api.datastructure import Credentials\n    from async_bakalari_api import Bakalari\n\n    # payload tak, jak ho vrac\u00ed server (kl\u00ed\u010de v\u010detn\u011b 'bak:UserId')\n    nove_udaje = {\n        \"bak:UserId\": \"user_id\",\n        \"access_token\": \"nov\u00fd access_token\",\n        \"refresh_token\": \"nov\u00fd refresh_token\",\n        \"username\": \"nov\u00e9 username\"\n    }\n\n    creds = Credentials.create(nove_udaje)\n    bakalari = Bakalari(server=\"http://server\", credentials=creds)\n</code></pre> <pre><code>    from async_bakalari_api.datastructure import Credentials\n    from async_bakalari_api import Bakalari\n\n    nove_udaje = {\n        \"user_id\": \"nov\u00e9 user_id\",\n        \"access_token\": \"nov\u00fd access_token\",\n        \"refresh_token\": \"nov\u00fd refresh_token\",\n        \"username\": \"nov\u00e9 username\"\n    }\n\n    creds = Credentials.create_from_json(nove_udaje)\n    bakalari = Bakalari(server=\"http://server\", credentials=creds)\n</code></pre>"},{"location":"bakalari/credentials/#nahrani-ulozenych-udaju","title":"Nahr\u00e1n\u00ed ulo\u017een\u00fdch \u00fadaj\u016f","text":"<p>Jak ji\u017e bylo \u0159e\u010deno, <code>Bakalari</code> umo\u017e\u0148uj\u00ed automatick\u00e9 ukl\u00e1d\u00e1n\u00ed <code>Credentials</code> do souboru ve form\u00e1tu <code>json</code></p> <p>Jejich z\u00edsk\u00e1n\u00ed zp\u011bt je mo\u017en\u00e9 pomoc\u00ed metody <code>load_credentials</code></p> <p>load_credentials(self, filename: str) -&gt; Credentials | bool</p> <p>Jako argument se zad\u00e1v\u00e1 jm\u00e9no souboru. Vrac\u00ed <code>Credentials</code>, kter\u00e9 tak\u00e9 hned ukl\u00e1d\u00e1 do <code>Bakalari.credentials</code></p> <p>P\u0159i ne\u00fasp\u011bchu vrac\u00ed <code>False</code></p> <p>Po zvol\u00e1n\u00ed metody <code>load_credentials</code> m\u00e1me tedy v instanci <code>bakalari</code> aktu\u00e1ln\u00ed \u00fadaje a lze je vyu\u017e\u00edt rovnou p\u0159i p\u0159ihl\u00e1\u0161en\u00ed.</p> <pre><code>    from async_bakalari_api.datastructure import Schools\n    from async_bakalari_api import Bakalari\n\n    school: Schools = await Schools().load_from_file(\"schools_data.json\")\n    bakalari = Bakalari(\n        server=school.get_url(\"\u010d\u00e1st jm\u00e9na \u0161koly\"), \n        auto_cache_credentials=True,\n        cache_filename=\"credentials.json\"\n    )\n    bakalari.load_credentials(\"credentials.json\")\n\n    ... nyn\u00ed ji\u017e m\u016f\u017eeme prov\u00e1d\u011bt autorizovan\u00e9 dotazy na server \u0161koly\n</code></pre>"},{"location":"bakalari/first_login/","title":"P\u0159ihl\u00e1\u0161en\u00ed jm\u00e9nem a heslem (prvn\u00ed p\u0159ihl\u00e1\u0161en\u00ed)","text":"<pre><code>async def first_login(self, username: str, password: str) -&gt; Credentials:\n\nasync def refresh_access_token(self) -&gt; Credentials:\n</code></pre> <p>Exceptions</p> <ul> <li>first_login: p\u0159i neplatn\u00fdch p\u0159ihla\u0161ovac\u00edch \u00fadaj\u00edch vyvol\u00e1 <code>Ex.InvalidLogin</code></li> <li>refresh_access_token: pokud nen\u00ed dostupn\u00fd <code>refresh_token</code> nebo je expirovan\u00fd/neplatn\u00fd, vyvol\u00e1 <code>Ex.RefreshTokenExpired</code></li> </ul> <p>Pro z\u00edsk\u00e1n\u00ed nov\u00e9ho <code>access_tokenu</code> a <code>refresh_tokenu</code> se pou\u017e\u00edv\u00e1 funkce <code>first_login</code>. Tato funkce se takt\u00e9\u017e vol\u00e1 p\u0159i vypr\u0161en\u00ed <code>refresh_tokenu</code>, kdy ji\u017e nelze automaticky z\u00edskat <code>access_token</code>.</p> <p>Zavol\u00e1n\u00edm <code>first_login</code> se <code>Credentials</code> ulo\u017e\u00ed do <code>Bakalari.credentials</code> a z\u00e1rove\u0148 jsou nov\u00e9 p\u0159\u00edstupov\u00e9 \u00fadaje vr\u00e1ceny zp\u011bt, pokud je chcete ukl\u00e1dat n\u011bkam do datab\u00e1ze.</p> <p>Automatick\u00e9 ukl\u00e1d\u00e1n\u00ed p\u0159\u00edstupov\u00fdch \u00fadaj\u016f</p> <p>Pokud je zapnut\u00e1 funkce <code>auto_cache_credentials</code> a je zad\u00e1n <code>cache_filename</code>: - p\u0159i inicializaci se klient pokus\u00ed na\u010d\u00edst <code>Credentials</code> ze souboru, - po \u00fasp\u011b\u0161n\u00e9m <code>first_login()</code> se nov\u00e9 tokeny ulo\u017e\u00ed do souboru, - p\u0159i automatick\u00e9m obnoven\u00ed p\u0159es <code>refresh_access_token()</code> se aktualizovan\u00e9 tokeny tak\u00e9 ulo\u017e\u00ed.</p> <p>Pozn\u00e1mky: - autorizovan\u00e9 po\u017eadavky p\u0159i expirovan\u00e9m/invalidn\u00edm <code>access_token</code> spust\u00ed automatick\u00fd refresh a po\u017eadavek se provede znovu (max. 1 pokus), - pokud nen\u00ed dostupn\u00fd platn\u00fd <code>refresh_token</code>, obnoven\u00ed sel\u017ee s <code>Ex.RefreshTokenExpired</code> a je pot\u0159eba znovu zavolat <code>first_login()</code>, - vlastnost <code>Bakalari.credentials</code> je pouze pro \u010dten\u00ed; aktualizuje se intern\u011b po <code>first_login()</code>/<code>refresh_access_token()</code>.</p>"},{"location":"bakalari/schools/","title":"T\u0159\u00edda Schools","text":"<p>T\u0159\u00edda Schools je ur\u010dena pro uchov\u00e1n\u00ed seznamu \u0161kol a jejich URL pro Bakalari API.</p> <p>Umo\u017e\u0148uje vyhledat \u0161kolu/y</p> <ul> <li>podle jm\u00e9na \u0161koly nebo \u010d\u00e1sti jm\u00e9na \u0161koly</li> <li>vyhled\u00e1 \u0161koly podle m\u011bsta</li> <li>lze hledat i podle URL endpointu</li> </ul> <p>Pozn\u00e1mka</p> <p>T\u0159\u00edda Schools uchov\u00e1v\u00e1 polo\u017eky v seznamu <code>Schools.school_list</code> jako instance t\u0159\u00eddy <code>School</code></p> <pre><code>@dataclass\nclass School:\n    \"\"\"Data structure for one school item.\"\"\"\n\n    name: str | None = None\n    api_point: str | None = None\n    town: str | None = None\n</code></pre>"},{"location":"bakalari/schools/#metody-tridy-schools","title":"Metody t\u0159\u00eddy <code>Schools</code>","text":""},{"location":"bakalari/schools/#append_school","title":"append_school","text":"<p><pre><code>    def append_school(self, name: str, api_point: str, town: str) -&gt; bool: \n</code></pre> Slou\u017e\u00ed k jednoduch\u00e9mu p\u0159id\u00e1n\u00ed nov\u00e9 \u0161koly do seznamu \u0161kol. V\u0161echny argumeny jsou povinn\u00e9 a nesm\u00ed b\u00fdt <code>None</code> nebo pr\u00e1zdn\u00fd \u0159et\u011bzec.</p> <p>Vrac\u00ed <code>True</code> nebo <code>False</code></p>"},{"location":"bakalari/schools/#get_url","title":"get_url","text":"<p><pre><code>    def get_url(self, name: str | None = None, idx: int | None = None) -&gt; str | bool:\n        \"\"\"Return url of school from name or index in dictionary.\n\n        Only one must be specified - name or index, otherwise returns False\n        If name or index is not found in dictionary returns False.\n        \"\"\"\n</code></pre> Vrac\u00ed URL pro \u0161kolu podle jm\u00e9na, \u010d\u00e1sti jm\u00e9na (\u010d\u00e1st jm\u00e9na mus\u00ed b\u00fdt jedine\u010dn\u00e1) nebo indexu ve slovn\u00edku.</p> <p>Vrac\u00ed URL \u0161koly pokud \u0161kola exituje, jinak <code>False</code></p>"},{"location":"bakalari/schools/#get_schools_by_town","title":"get_schools_by_town","text":"<pre><code>    get_schools_by_town(self, town: str | None = None) -&gt; list[School]\n</code></pre> <p>Vrac\u00ed seznam \u0161kol v dan\u00e9m m\u011bst\u011b.</p> <p>Vrac\u00ed <code>list[School]</code> (m\u016f\u017ee b\u00fdt pr\u00e1zdn\u00fd).</p>"},{"location":"bakalari/schools/#get_school_name_by_api_point","title":"get_school_name_by_api_point","text":"<pre><code>    def get_school_name_by_api_point(self, api_point: str) -&gt; str | bool\n</code></pre> <p>Vrac\u00ed n\u00e1zev \u0161koly podle jej\u00edho API.</p>"},{"location":"bakalari/schools/#save_to_file","title":"save_to_file","text":"<pre><code>    async def save_to_file(self, filename: str) -&gt; bool\n</code></pre> <p>Ukl\u00e1d\u00e1 na\u010dten\u00fd seznam \u0161kol do souboru ve form\u00e1tu JSON.</p> <p>P\u0159i chyb\u011b parsov\u00e1n\u00ed JSON nebo chyb\u011b z\u00e1pisu vrac\u00ed <code>False</code>, jinak <code>True</code></p>"},{"location":"bakalari/schools/#load_from_file","title":"load_from_file","text":"<pre><code>    async def load_from_file(self, filename: str) -&gt; Schools | bool\n</code></pre> <p>Na\u010dte seznam \u0161kol ze souboru v JSON form\u00e1tu.</p> <p>Vrac\u00ed <code>Schools</code> s na\u010dten\u00fdmi \u0161kolami, p\u0159i chyb\u011b parsov\u00e1n\u00ed JSON nebo chyb\u011b otev\u0159en\u00ed souboru vrac\u00ed <code>False</code></p>"},{"location":"bakalari/seznam_skol/","title":"Seznam \u0161kol","text":"<p>Seznam \u0161kol se z\u00edsk\u00e1v\u00e1 metodou na t\u0159\u00edd\u011b <code>Bakalari</code>. Samotn\u00e1 datov\u00e1 struktura seznamu je <code>Schools</code> (viz <code>async_bakalari_api.datastructure</code>).</p> <pre><code>async def schools_list(self, town: str | None = None, recursive: bool = True) -&gt; Schools | None:\n</code></pre> <ul> <li>Parametry:</li> <li><code>town (str | None)</code>: voliteln\u00fd filtr na n\u00e1zev m\u011bsta.</li> <li> <p><code>recursive (bool)</code>: zp\u016fsob filtrov\u00e1n\u00ed podle <code>town</code>:</p> <ul> <li><code>True</code> (v\u00fdchoz\u00ed): vybere m\u011bsta, kter\u00e1 obsahuj\u00ed \u0159et\u011bzec <code>town</code> kdekoliv v n\u00e1zvu.</li> <li><code>False</code>: vybere pouze m\u011bsta, jejich\u017e n\u00e1zev za\u010d\u00edn\u00e1 na <code>town</code>.</li> </ul> </li> <li> <p>Chov\u00e1n\u00ed:</p> </li> <li>Metoda vol\u00e1 ve\u0159ejn\u00fd endpoint Bakal\u00e1\u0159\u016f pro seznam m\u011bst a pro ka\u017ed\u00e9 vybran\u00e9 m\u011bsto st\u00e1hne \u0161koly.</li> <li>Po \u00fasp\u011bchu vrac\u00ed instanci <code>Schools</code> a z\u00e1rove\u0148 ji ulo\u017e\u00ed do <code>self.schools</code>.</li> <li>P\u0159i chyb\u011b vrac\u00ed <code>None</code>.</li> </ul> <p>Soub\u011b\u017en\u00e9 dotazy</p> <p>Po\u010det soub\u011b\u017en\u00fdch dotaz\u016f na m\u011bsta p\u0159i sestavov\u00e1n\u00ed seznamu \u0161kol je omezen parametrem <code>school_concurrency</code> v konstruktoru <code>Bakalari</code> (v\u00fdchoz\u00ed 10).</p> <p>Omezen\u00ed dotaz\u016f</p> <p>Seznam \u0161kol je pom\u011brn\u011b dlouh\u00fd: 3105 \u0161kol v 1208 m\u011bstech, tedy i 1208 dotaz\u016f na server Bakal\u00e1\u0159\u016f.</p> <p>Nedoporu\u010duje se stahovat cel\u00fd seznam p\u0159i ka\u017ed\u00e9m spu\u0161t\u011bn\u00ed. M\u00edsto toho: - pou\u017eijte filtr <code>town</code> (a voliteln\u011b <code>recursive=False</code> pro prefixov\u00e9 vyhled\u00e1v\u00e1n\u00ed), - ukl\u00e1dejte v\u00fdsledek do souboru pomoc\u00ed metod <code>save_to_file</code> / <code>load_from_file</code>.</p> <pre><code># filtr dle m\u011bsta (substring)\nschools: Schools | None = await bakalari.schools_list(town=\"po\u017eadovan\u00e9 m\u011bsto\")\n</code></pre> <p>P\u0159i \u00fasp\u011bchu vrac\u00ed <code>Schools</code>, p\u0159i chyb\u011b <code>None</code>. V\u00edce o t\u0159\u00edd\u011b <code>Schools</code></p> <p>P\u0159\u00edklad pou\u017eit\u00ed</p> CLINa\u010dten\u00ed \u0161kol ze serveruNa\u010dten\u00ed jen m\u011bst za\u010d\u00ednaj\u00edc\u00edch na 'Praha'Ulo\u017een\u00ed/na\u010dten\u00ed ze souboruPou\u017eit\u00ed s Bakalari <pre><code># ulo\u017een\u00ed cel\u00e9ho seznamu \u0161kol do souboru\nbakalari -N schools -s \"skoly.json\"\n\n# vyps\u00e1n\u00ed \u0161kol z ur\u010dit\u00e9ho m\u011bsta\nbakalari -N -t \"m\u011bsto\" schools -l\n</code></pre> <pre><code>from async_bakalari_api import Bakalari\n\nbakalari = Bakalari()\nseznam_skol = await bakalari.schools_list()\n</code></pre> <pre><code>from async_bakalari_api import Bakalari\n\nbakalari = Bakalari()\npraha_skoly = await bakalari.schools_list(town=\"Praha\", recursive=False)\n</code></pre> <pre><code>from async_bakalari_api.datastructure import Schools\n\n# ulo\u017een\u00ed\nschools = await Bakalari().schools_list()\nif schools:\n    await schools.save_to_file(\"skoly.json\")\n\n# na\u010dten\u00ed\nschools_from_file: Schools = await Schools().load_from_file(\"skoly.json\")\n</code></pre> <pre><code>from async_bakalari_api import Bakalari\nfrom async_bakalari_api.datastructure import Schools\n\nschools: Schools = await Schools().load_from_file(\"schools_data.json\")\nbakalari = Bakalari(schools.get_url(\"Jm\u00e9no \u0161koly/\u010d\u00e1st jm\u00e9na \u0161koly\"))\n</code></pre>"},{"location":"cli/","title":"CLI (Command Line Interface)","text":"<p>Bal\u00ed\u010dek <code>async_bakalari_api</code> poskytuje tak\u00e9 u\u017eivatelsk\u00e9 rozhran\u00ed pro p\u0159\u00edkazovou \u0159\u00e1dku <code>CLI</code>.</p> <p>Po instalaci je automaticky dostupn\u00fd p\u0159\u00edkaz <code>bakalari</code> z termin\u00e1lu nebo p\u0159\u00edkazov\u00e9 \u0159\u00e1dky.</p> <p>N\u00e1pov\u011bda k u\u017eit\u00ed <code>bakalari</code> se vyvol\u00e1 p\u0159\u00edkazem <code>bakalari -h</code></p> <pre><code>bakalari -h\n\nusage: bakalari [-h] [-N] [-F jm\u00e9no heslo] [-Ff SOUBOR] [-C] [-cf soubor s tokeny] [--auto_cache soubor s tokeny]\n                [-t M\u011bsto] [-s \u0160KOLA] [-sf SOUBOR.json] [-r | -nr] [-v]\n                {schools,komens,timetable} ...\n\nBakalari DEMO App\n\noptions:\n  -h, --help            show this help message and exit\n  -t M\u011bsto, --town M\u011bsto\n                        Omez\u00ed stahov\u00e1n\u00ed a dotazy pouze na jedno m\u011bsto\n  -s \u0160KOLA, --school \u0160KOLA\n                        N\u00e1zev \u0161koly nebo \u010d\u00e1st n\u00e1zvu \u0161koly\n  -sf SOUBOR.json, --schools_file SOUBOR.json\n                        Na\u010dte seznam \u0161kol ze zadan\u00e9ho souboru (form\u00e1t JSON)\n  -r, --recursive       Povol\u00ed rekurzivn\u00ed (pod\u0159et\u011bzcov\u00e9) vyhled\u00e1v\u00e1n\u00ed (v\u00fdchoz\u00ed).\n  -nr, --no-recursive   Zak\u00e1\u017ee rekurzivn\u00ed vyhled\u00e1v\u00e1n\u00ed (pou\u017eije se pouze prefix).\n  -v, --verbose         Zapne podrobn\u00e9 logov\u00e1n\u00ed\n\nP\u0159ihl\u00e1\u0161en\u00ed (po\u017eadov\u00e1no):\n  Zvolte typ p\u0159ihl\u00e1\u0161en\u00ed heslo / tokenu\n\n  -N, --no_login        Provede neautorizovan\u00fd p\u0159\u00edstup\n  -F jm\u00e9no heslo, --first_login jm\u00e9no heslo\n                        Provede p\u0159ihl\u00e1\u0161en\u00ed jm\u00e9nem a heslem. Pokud je zad\u00e1n parametr -cf, pak zap\u00ed\u0161e tokeny do tohoto\n                        souboru. Jinak tokeny zobraz\u00ed na v\u00fdstup. Pokud je pou\u017eit parametr --auto_cache, pak se tokeny\n                        zap\u00ed\u0161\u00ed do tohoto souboru i do souboru zadan\u00e9ho v parametru -cf. \u0160kola m\u016f\u017ee b\u00fdt pouze \u010d\u00e1st\n                        n\u00e1zvu, ale n\u00e1zev mus\u00ed b\u00fdt jedine\u010dn\u00fd v seznamu \u0161kol. Pro rychlej\u0161\u00ed vyhled\u00e1v\u00e1n\u00ed m\u016f\u017eete p\u0159idat\n                        parametr -t k vyhled\u00e1v\u00e1n\u00ed pouze ve zvolen\u00e9m m\u011bst\u011b.\n  -Ff SOUBOR, --first_login_file SOUBOR\n                        P\u0159ihl\u00e1\u0161en\u00ed se jm\u00e9nem a heslem na\u010dten\u00fdch ze souboru. Soubor s p\u0159ihla\u0161ovac\u00edm jm\u00e9nem a heslem ve\n                        form\u00e1tu JSON.\n  -C, --credentials     P\u0159ihl\u00e1\u0161en\u00ed pomoc\u00ed tokenu. Vy\u017eaduje parametr -cf\n  -cf soubor s tokeny, --credentials_file soubor s tokeny\n                        Jm\u00e9no souboru odkud se maji na\u010d\u00edst tokeny.\n  --auto_cache soubor s tokeny\n                        Pou\u017e\u00edt automatick\u00e9 ke\u0161ov\u00e1n\u00ed token\u016f. Povinn\u00fd je parametr jm\u00e9no souboru do kter\u00e9ho se m\u00e1 ke\u0161ovat.\n\nSeznam p\u0159\u00edkaz\u016f:\n  {schools,komens,timetable}\n    schools             Seznam \u0161kol\n    komens              Komens\n    timetable           Rozvrh (timetable)\n</code></pre>"},{"location":"cli/#rozvrh-timetable","title":"Rozvrh (timetable)","text":"<pre><code>bakalari timetable -h\nusage: bakalari timetable [-h] [-p] [-d YYYY-MM-DD] [--class ID | --group ID | --teacher ID | --room ID | --student ID]\n\noptions:\n  -h, --help            show this help message and exit\n  -p, --permanent       Na\u010dte pevn\u00fd (permanentn\u00ed) rozvrh m\u00edsto aktu\u00e1ln\u00edho.\n  -d YYYY-MM-DD, --date YYYY-MM-DD\n                        Datum t\u00fddne pro aktu\u00e1ln\u00ed rozvrh ve form\u00e1tu YYYY-MM-DD. Pokud nen\u00ed zad\u00e1no, pou\u017eije se dne\u0161n\u00ed datum.\n  --class ID            ID t\u0159\u00eddy (classId) pro zobrazen\u00ed rozvrhu.\n  --group ID            ID skupiny (groupId) pro zobrazen\u00ed rozvrhu.\n  --teacher ID          ID u\u010ditele (teacherId) pro zobrazen\u00ed rozvrhu.\n  --room ID             ID m\u00edstnosti (roomId) pro zobrazen\u00ed rozvrhu.\n  --student ID          ID studenta (studentId) pro zobrazen\u00ed rozvrhu.\n</code></pre> <p>Glob\u00e1ln\u00ed p\u0159ep\u00edna\u010de <code>-r/--recursive</code> a <code>-nr/--no-recursive</code> ovliv\u0148uj\u00ed, jak se vyhled\u00e1v\u00e1 \u0161kola/m\u011bsto (pod\u0159et\u011bzcov\u011b vs. pomoc\u00ed prefixu).</p>"},{"location":"cli/komens/","title":"Zpr\u00e1vy (Komens)","text":"<pre><code>bakalari komens -h\nusage: bakalari komens [-h] [-u] [-sa] [-l | -e ID_zpr\u00e1vy | -s SOUBOR] [--attachment ID_p\u0159\u00edlohy]\n\noptions:\n  -h, --help            show this help message and exit\n  -u, --unread          Vyp\u00ed\u0161e nep\u0159e\u010dten\u00e9 zpr\u00e1vy\n  -sa, --save_attachment\n                        Ulo\u017e\u00ed automaticky p\u0159\u00edlohy zpr\u00e1v do souboru\n  -l, --list            Vyp\u00ed\u0161e p\u0159ijat\u00e9 zpr\u00e1vy\n  -e ID_zpr\u00e1vy, --extend ID_zpr\u00e1vy\n                        Vyp\u00ed\u0161e podrobn\u011b zpr\u00e1vu s ID zpr\u00e1vy.\n  -s SOUBOR, --save SOUBOR\n                        Ulo\u017e\u00ed zpr\u00e1vy do souboru\n  --attachment ID_p\u0159\u00edlohy\n                        St\u00e1hne p\u0159\u00edlohu zpr\u00e1vy.\n</code></pre> <p>P\u0159ihl\u00e1\u0161en\u00ed</p> <p>K vyu\u017eit\u00ed Komens ji\u017e mus\u00edme m\u00edt p\u0159ihl\u00e1\u0161en\u00ed ke \u0161kole v podob\u011b bu\u010f jm\u00e9no/helso nebo platn\u00e9 tokeny. Jejich z\u00edsk\u00e1n\u00ed je pos\u00e1no zde</p> V\u00fdpis v\u0161ech zpr\u00e1v do termin\u00e1luUlo\u017een\u00ed v\u0161ech zpr\u00e1v do souboru <pre><code>bakalari --auto_cache tokeny.json -sf seznam_skol.json -s \"Gymn\u00e1zium \u017didlochovice\" komens -l\n</code></pre> <pre><code>bakalari --auto_cache tokeny.json -sf seznam_skol.json -s \"Gymn\u00e1zium \u017didlochovice\" komens -s zpravy.json\n</code></pre> <p>Pokud jsou na severu nep\u0159e\u010detn\u00e9 zpr\u00e1vy, lze je z\u00edskat pou\u017eit\u00edm <code>-u</code></p> V\u00fdpis nep\u0159e\u010dten\u00fdch zpr\u00e1vUlo\u017een\u00ed nep\u0159e\u010dten\u00fdch zpr\u00e1v <pre><code>bakalari --auto_cache tokeny.json -sf seznam_skol.json -s \"Gymn\u00e1zium \u017didlochovice\" komens -u -l\n</code></pre> <pre><code>    bakalari --auto_cache tokeny.json -sf seznam_skol.json -s \"Gymn\u00e1zium \u017didlochovice\" komens -u -s zpravy.json\"\n</code></pre>"},{"location":"cli/komens/#prilohy","title":"P\u0159\u00edlohy","text":"<p>P\u0159\u00edlohy zpr\u00e1v lze st\u00e1hnout bu\u010f jednotliv\u011b, pokud zn\u00e1te <code>ID</code> p\u0159\u00edlohy nebo automaticky, pokud zpr\u00e1va p\u0159\u00edlohy obsahuje.</p> Sta\u017een\u00ed pr\u00edlohyAutomatick\u00e9 sta\u017een\u00ed p\u0159\u00edlohy <pre><code>bakalari --auto_cache tokeny.json -sf seznam_skol.json -s \"Gymn\u00e1zium \u017didlochovice\" komens --attachment ID\n</code></pre> <pre><code>bakalari --auto_cache tokeny.json -sf seznam_skol.json -s \"Gymn\u00e1zium \u017didlochovice\" komens -l -sa\n</code></pre>"},{"location":"cli/seznam_skol/","title":"Sta\u017een\u00ed seznamu \u0161kol","text":"<pre><code>usage: bakalari schools [-h] (-l | -s Jm\u00e9no souboru (form\u00e1t JSON))\n\noptions:\n  -h, --help            show this help message and exit\n  -l, --list            Vyp\u00ed\u0161e seznam v\u0161ech \u0161kol. S parameter -t vyp\u00ed\u0161e \u0161koly ze zvolen\u00e9ho m\u011bsta.\n  -s Jm\u00e9no souboru (form\u00e1t JSON), --save Jm\u00e9no souboru (form\u00e1t JSON)\n                        Ulo\u017e\u00ed seznam \u0161kol do souboru.\n</code></pre> <p>K pouh\u00e9mu sta\u017een\u00ed seznamu \u0161kol nepot\u0159ebujeme p\u0159ihl\u00e1\u0161en\u00ed. M\u016f\u017eeme proto vyu\u017e\u00edt parametr <code>-N</code> pro neutorizovan\u00e9 dotazy.</p> Zobrazen\u00ed kompletn\u00edho seznamuSta\u017een\u00ed komplezn\u00edho seznamu do souboru <pre><code>bakalari -N schools --list\n</code></pre> <pre><code>bakalari -N schools --list -s seznam_skol.json\n</code></pre> <p>Omezen\u00ed na m\u011bsto</p> <p>Pokud chcete v\u00fdsledky hled\u00e1n\u00ed omezit pouze na ur\u010dit\u00e9 m\u011bsto, pak lze pou\u017e\u00edt parametr <code>-t</code></p> <pre><code>bakalari -N -t Ostrava schools -l\n</code></pre> <p>Hled\u00e1n\u00ed v seznamu \u0161kol je rekursivn\u00ed. Znaman\u00e1 to tedy, \u017ee p\u0159i zad\u00e1n\u00ed <code>-t Ostrava</code> se vyhledaj\u00ed v\u0161echna m\u011bsta, kter\u00e1 obsahuj\u00ed <code>Ostrava</code>. Tedy i <code>Moravsk\u00e1 Ostrava</code> nebo <code>Slezsk\u00e1 Ostrava</code>.</p> <p>Stejn\u011b tak, pokud se zad\u00e1 pouze \u010d\u00e1st n\u00e1zvu m\u011bsta, nap\u0159. <code>Prost\u011bj</code> vyhled\u00e1 <code>Prostejov</code>, ale i <code>Brodek u Prost\u011bjova</code>.</p>"},{"location":"cli/tokeny/","title":"P\u0159ihl\u00e1\u0161en\u00ed a z\u00edsk\u00e1n\u00ed token\u016f","text":"<p>P\u0159ihl\u00e1\u0161en\u00ed k serveru \u0161koly lze prov\u00e9st troj\u00edm zp\u016fsobem.</p> <ul> <li>pou\u017eit\u00edm jm\u00e9na a hesla <code>-F</code></li> <li>pou\u017eit\u00edm souboru s tokeny (tyto se ale automaticky neuk\u00e1daj\u00ed) <code>-C -cf</code></li> <li>pou\u017eit\u00edm automatick\u00e9ho ke\u0161ov\u00e1n\u00ed token\u016f <code>--auto_cache</code></li> </ul> <p>Nutn\u00e9 parametry \u0161koly!</p> <p>Pro p\u0159ihl\u00e1\u0161en\u00ed je nutn\u00e9 zadat, ke kter\u00e9 \u0161kole se p\u0159ihla\u0161ujete.</p> <p>Je tedy nutn\u00e9 v\u017edy pou\u017e\u00edt parametr <code>-s \u0160KOLA</code> pop\u0159\u00edpad\u011b s parameterm seznamu \u0161kol <code>-s \u0160KOLA -sf seznam_skol.json</code></p> <p>Automatick\u00e9 vytvo\u0159en\u00ed konfigura\u010dn\u00edho souboru</p> <p>Od verze 0.3.3 je mo\u017en\u00e9 vytvo\u0159en\u00ed konfigura\u010dn\u00edho souboru s tokeny a API pointem \u0161koly.</p> <p>P\u0159i prvn\u00edm p\u0159ihl\u00e1\u0161en\u00ed lze pou\u017e\u00edt  <code>bakalari -a -F JMENO HESLO -t M\u011aSTO -s \u0160KOLA</code>  t\u00edm se vytvo\u0159\u00ed konfukura\u010dn\u00ed soubor a soubor s tokeny, kter\u00e9 se budou automaticky na\u010d\u00edtat p\u0159i dal\u0161\u00edm pou\u017eit\u00edm <code>-a</code> bez nutnosti zad\u00e1v\u00e1n\u00ed <code>-s</code>, <code>-sf</code>, <code>--auto_cache</code>, <code>-cf</code></p> Automatick\u00e9 ulo\u017een\u00edP\u0159ihl\u00e1\u0161en\u00ed heslem a zaps\u00e1n\u00ed token\u016f do souboruP\u0159ihl\u00e1\u0161en\u00ed pomoc\u00ed token\u016f bez ke\u0161ov\u00e1n\u00edP\u0159ihl\u00e1\u0161en\u00ed s autmatick\u00fdm ke\u0161ov\u00e1n\u00edm <pre><code>bakalari -a -f JEMENO HESLO -t M\u011aSTO -s \u0160KOLA\n</code></pre> <pre><code>bakalari -F JMENO HESLO -cf tokeny.json -s \u0160KOLA -t M\u011aSTO\n</code></pre> <pre><code>bakalri -C -cf tokeny.json -s \u0160KOLA -sf seznam_\u0161kol\n</code></pre> <pre><code>bakalari --auto_cache tokeny.json -s \u0160KOLA -sf seznam_\u0161kol\n</code></pre>"},{"location":"komens/","title":"Modul Komens","text":"<p>Tento modul slou\u017e\u00ed k z\u00edsk\u00e1n\u00ed p\u0159ijat\u00fdch zpr\u00e1v ze serveru \u0161koly. Tento modul ji\u017e prov\u00e1d\u00ed autorizovan\u00e9 dotazy, tak\u017ee je nutn\u00e9 ji\u017e m\u00edt \u00fadaje o tokenech, p\u0159\u00edpadn\u011b prov\u00e9st prvn\u00ed p\u0159ihl\u00e1\u0161en\u00ed.</p> <pre><code>    class Komens:\n    \"\"\"Class for working with Komens messages.\"\"\"\n\n    def __init__(self, bakalari: Bakalari):\n        \"\"\"Initialize class Komens.\"\"\"\n        self.bakalari = bakalari\n        self.messages = Messages()\n</code></pre> <p>Jako jedin\u00fd parametr p\u0159ij\u00edm\u00e1 inicializovanou instanci <code>Bakalari</code></p> <pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n\n    komens = Komens(bakalari)\n</code></pre>"},{"location":"komens/#nacteni-prijatych-zprav","title":"Na\u010dten\u00ed p\u0159ijat\u00fdch zpr\u00e1v","text":"<p>Na\u010dten\u00ed zpr\u00e1v prob\u00edh\u00e1 metodou <code>Komens.fetch_messages()</code>.</p> <p>Tato metoda nejprve vyma\u017ee dosud ulo\u017een\u00e9 zpr\u00e1vy a st\u00e1hne aktu\u00e1ln\u00ed zpr\u00e1vy ze serveru \u0161koly. Vrac\u00ed instanci <code>Messages</code> (seznam <code>MessageContainer</code>) a z\u00e1rove\u0148 ji ulo\u017e\u00ed do <code>Komens.messages</code>.</p> <pre><code>Messages = list[MessageContainer]\n</code></pre> <p>Messages</p> <p>ke zpr\u00e1v\u00e1m lze p\u0159istupovat z prom\u011bnn\u00e9 <code>Komens.messages</code></p> <p>V\u00edce o <code>Messages</code> a <code>MessageContainer</code> bude k dispozici Dev dokumentaci pozd\u011bji. Pro u\u017eit\u00ed v b\u011b\u017en\u00e9m re\u017eimu nen\u00ed t\u0159eba se jimi zab\u00fdvat do hloubky.</p>"},{"location":"komens/#neprectene-zpravy","title":"Nep\u0159e\u010dten\u00e9 zpr\u00e1vy","text":"<ul> <li>Z\u00edskat seznam nep\u0159e\u010dten\u00fdch zpr\u00e1v:</li> </ul> <pre><code>async def get_unread_messages(self) -&gt; list[MessageContainer]:\n</code></pre> <p>Vr\u00e1t\u00ed list pouze t\u011bch zpr\u00e1v, kter\u00e9 maj\u00ed <code>read=False</code>. Pokud dosud nejsou zpr\u00e1vy na\u010dten\u00e9, metoda si je nejprve st\u00e1hne.</p> <ul> <li>Z\u00edskat po\u010det nep\u0159e\u010dten\u00fdch zpr\u00e1v:</li> </ul> <pre><code>async def count_unread_messages(self) -&gt; int:\n</code></pre> <p>Vrac\u00ed po\u010det nep\u0159e\u010dten\u00fdch zpr\u00e1v; vyu\u017e\u00edv\u00e1 p\u0159\u00edm\u00fd endpoint (nen\u00ed nutn\u00e9 m\u00edt zavolan\u00e9 <code>fetch_messages()</code>).</p> Na\u010dten\u00ed zpr\u00e1v ze serveru<pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n\n    komens = Komens(bakalari)\n    await komens.fetch_messages()\n</code></pre>"},{"location":"komens/cteni_zprav/","title":"\u010cten\u00ed p\u0159ijat\u00fdch zpr\u00e1v","text":"<p>Pokud ji\u017e m\u00e1me zpr\u00e1vy sta\u017eeny ze serveru, jsou ulo\u017eeny v <code>Komens.messages</code>, kter\u00fd p\u0159edstavuje seznam zpr\u00e1v ve form\u00e1tu <code>Messages</code>. Ka\u017ed\u00e1 zpr\u00e1va je reprezentov\u00e1na jako <code>MessageContainer</code></p>"},{"location":"komens/cteni_zprav/#celkovy-pocet-prijatych-zprav","title":"Celkov\u00fd po\u010det p\u0159ijat\u00fdch zpr\u00e1v","text":"<pre><code>    Komens.messages.count_messages()\n</code></pre> <p>Vrac\u00ed <code>int</code> jako celkov\u00fd po\u010det zpr\u00e1v</p>"},{"location":"komens/cteni_zprav/#zprava-podle-data-rozsahu-dat","title":"Zpr\u00e1va podle data / rozsahu dat","text":"<p>Pokud chceme zobrazit zpr\u00e1vy jen z ur\u010dit\u00e9ho dne nebo rozsahu dn\u00ed, pak k tomu slou\u017e\u00ed metoda <code>get_messages_by_date()</code></p> <pre><code>    def get_messages_by_date(\n        self, date: datetime | date, to_date: datetime | date | None = None\n    ) -&gt; list[MessageContainer]:\n        \"\"\"Get messages by date.\n\n        If `to_date` is set, returns messages in the inclusive range &lt;date, to_date&gt;.\n        Raises ValueError if `to_date` is before `date`.\n        \"\"\"\n</code></pre> DenRozsah dn\u00ed <pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n    from datetime import date\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n\n    komens = Komens(bakalari)\n    await komens.fetch_messages()\n\n    zpravy_ze_dne = komens.messages.get_messages_by_date(date.today())\n    for msg in zpravy_ze_dne:\n        print(msg, end=\"\\n --- \\n\")\n</code></pre> Zpr\u00e1vy za posledn\u00edch 30 dn\u00ed<pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n    import datetime\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n\n    komens = Komens(bakalari)\n    await komens.fetch_messages()\n\n    zpravy_ze_dne = komens.messages.get_messages_by_date(\n            datetime.date.today() + datetime.timedelta(days=-30),\n            to_date=datetime.date.today()\n        )\n    print(msg for msg in zpravy_ze_dne)\n</code></pre>"},{"location":"komens/cteni_zprav/#zprava-podle-id_zpravy","title":"Zpr\u00e1va podle ID_zpr\u00e1vy","text":"<p>Pokud chceme p\u0159e\u010d\u00edst konkr\u00e9tn\u00ed zpr\u00e1vu s <code>ID_zpr\u00e1vy</code> slou\u017e\u00ed k tomu metoda <code>get_message_by_id</code></p> <pre><code>    def get_message_by_id(self, id: str) -&gt; MessageContainer\n</code></pre> PyCLI <pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n\n    komens = Komens(bakalari)\n    await komens.fetch_messages()\n\n    zprava = komens.messages.get_message_by_id(\"1\")\n    print(zprava)\n</code></pre> <pre><code># p\u0159ihl\u00e1\u0161en\u00ed pomoc\u00ed token\u016f (-C) ze souboru credentials.json (-cf)\n# \u0161koly na\u010dti ze souboru skoly.json (-sf)\n# pou\u017eij url \u0161koly \"\u0161kola\"\n# a z komens na\u010dti zpr\u00e1vy (--messages) a vypi\u0161 zpr\u00e1vu s ID 1 (-e 1)\n\nbakalari -C -cf credentials.json -sf skoly.json -s \"\u0161kola\" komens --messages -e 1\n</code></pre>"},{"location":"komens/stazeni_prilohy/","title":"Sta\u017een\u00ed p\u0159\u00edlohy zpr\u00e1vy","text":"<p>Zpr\u00e1vy v Komens mohou obsahovat p\u0159\u00edlohy, kter\u00e9 maj\u00ed sv\u00e9 <code>ID</code> (typ <code>str</code>). Sta\u017een\u00ed p\u0159\u00edlohy je mo\u017en\u00e9 p\u0159\u00edkazem <code>Komens.get_attachment</code>.</p> <pre><code>    async def get_attachment(self, id: str) -&gt; tuple[str, bytes]:\n</code></pre> <p>Vrac\u00ed tuple (filename: str, filedata: bytes)</p> <p>P\u0159i chyb\u011b vrac\u00ed False (nap\u0159. expirovan\u00e9/invalidn\u00ed tokeny, s\u00ed\u0165ov\u00e1 chyba apod.). Vol\u00e1n\u00ed je autorizovan\u00e9; p\u0159i expirovan\u00e9m access tokenu se provede automatick\u00fd refresh p\u0159es refresh token a po\u017eadavek se zopakuje.</p> PyCLI P\u0159\u00edklad ulo\u017een\u00ed p\u0159\u00edlohy do souboru.<pre><code>    from async_bakalari_api import Bakalari\n    from async_bakalari_api.komens import Komens\n\n    bakalari = Bakalari(\"http://server\")\n    bakalari.load_credentials(\"credentials.json\")\n    komens = Komens(bakalari)\n\n    filename, filedata = await komens.get_attachment(\"ID_p\u0159\u00edlohy\")\n\n    with open(filename, \"wb\") as fi:\n        fi.write(filedata)\n</code></pre> <pre><code># p\u0159ihla\u0161 se automaticky pomoc\u00ed token\u016f (--autocache)\n# na\u010dti \u0161koly ze souboru skoly.json (-sf)\n# pou\u017eij url \u0161koly \"\u0161kola\"\n# z komens st\u00e1hni zpr\u00e1vy (--messages)\n# ulo\u017e p\u0159\u00edlohu s ID p\u0159\u00edlohy 1\n\nbakalari --auto_cache credentials.json -sf skoly.json -s \"\u0161kola\" komens --messages --attachment 1\n</code></pre>"},{"location":"marks/","title":"Modul Marks","text":"<p>Modul <code>Marks</code> slou\u017e\u00ed k na\u010d\u00edt\u00e1n\u00ed a pr\u00e1ci se zn\u00e1mkami. Um\u00ed: - st\u00e1hnout zn\u00e1mky ze serveru \u0161koly, - pracovat s p\u0159edm\u011bty a jejich zn\u00e1mkami (v\u010detn\u011b nov\u00fdch zn\u00e1mek), - filtrovat zn\u00e1mky podle data nebo rozsahu datum\u016f, - vracet zn\u00e1mky seskupen\u00e9 podle p\u0159edm\u011bt\u016f, - form\u00e1tovan\u00fd v\u00fdstup</p> <p>Tento modul ji\u017e prov\u00e1d\u00ed autorizovan\u00e9 dotazy, tak\u017ee je nutn\u00e9 ji\u017e m\u00edt \u00fadaje o tokenech, p\u0159\u00edpadn\u011b prov\u00e9st prvn\u00ed p\u0159ihl\u00e1\u0161en\u00ed.</p>"},{"location":"marks/#trida-marks","title":"T\u0159\u00edda Marks","text":"class Marks<pre><code>from async_bakalari_api import Bakalari\n\nclass Marks:\n    \"\"\"Marks class.\"\"\"\n\n    def __init__(self, bakalari: Bakalari): ...\n</code></pre> <p>Jako jedin\u00fd parametr p\u0159ij\u00edm\u00e1 inicializovanou instanci <code>Bakalari</code>.</p> <pre><code>from async_bakalari_api import Bakalari\nfrom async_bakalari_api.marks import Marks\n\nbakalari = Bakalari(\"http://server\")\nbakalari.load_credentials(\"credentials.json\")\n\nmarks = Marks(bakalari)\n</code></pre>"},{"location":"marks/#nacteni-znamek-ze-serveru","title":"Na\u010dten\u00ed zn\u00e1mek ze serveru","text":"<p>Zn\u00e1mky na\u010dte metoda <code>fetch_marks()</code>.</p> <p>Metoda se nevol\u00e1 automaticky p\u0159i inicializaci t\u0159\u00eddy <code>Marks</code>. Je nutn\u00e9 ji volat ru\u010dn\u011b v\u017edy, kdy\u017e chcete aktualizovat zn\u00e1mky.</p> Na\u010dten\u00ed zn\u00e1mek<pre><code>await marks.fetch_marks()\n</code></pre> <p>Upozorn\u011bn\u00ed</p> <p>Pro spr\u00e1vn\u00e9 fungov\u00e1n\u00ed je nutn\u00e9 m\u00edt platn\u00e9 p\u0159ihla\u0161ovac\u00ed \u00fadaje (tokeny) v instanci <code>Bakalari</code>.</p>"},{"location":"marks/#datove-struktury","title":"Datov\u00e9 struktury","text":"<p>Zn\u00e1mky a p\u0159edm\u011bty se ukl\u00e1daj\u00ed do speci\u00e1ln\u00edch t\u0159\u00edd, kter\u00e9 modul pou\u017e\u00edv\u00e1 intern\u011b i v n\u00e1vratov\u00fdch hodnot\u00e1ch API:</p> <ul> <li><code>SubjectsBase</code></li> <li><code>id: str</code> \u2014 identifik\u00e1tor p\u0159edm\u011btu</li> <li><code>abbr: str</code> \u2014 zkratka p\u0159edm\u011btu</li> <li><code>name: str</code> \u2014 n\u00e1zev p\u0159edm\u011btu</li> <li><code>average_text: str</code> \u2014 textov\u00fd pr\u016fm\u011br (\u0159e\u0161\u00ed server)</li> <li><code>points_only: bool</code> \u2014 zda je p\u0159edm\u011bt pouze bodov\u011b hodnocen</li> <li> <p><code>marks: MarksRegistry</code> \u2014 kolekce zn\u00e1mek pro dan\u00fd p\u0159edm\u011bt</p> </li> <li> <p><code>MarksBase</code></p> </li> <li><code>id: str</code> - id zn\u00e1mky</li> <li><code>date: datetime</code> - datum zn\u00e1mky</li> <li><code>caption: str</code> - text zn\u00e1mky</li> <li><code>theme: str | None</code> - n\u00e1zev t\u00e9matu zn\u00e1mky</li> <li><code>marktext: MarkOptionsBase | None</code> \u2014 textov\u00e1 reprezentace zn\u00e1mky (1, A, +, apod.)</li> <li><code>teacher: str | None</code> - u\u010ditel, kter\u00fd vydal zn\u00e1mku</li> <li><code>subject_id: str</code> - identifik\u00e1tor p\u0159edm\u011btu</li> <li><code>is_new: bool</code> - nov\u00e1 zn\u00e1mka</li> <li><code>is_points: bool</code> - zda je zn\u00e1mka bodov\u00e1</li> <li><code>points_text: str | None</code> - textov\u00e1 reprezentace bod\u016f</li> <li> <p><code>max_points: int | None</code> - maxim\u00e1ln\u00ed po\u010det bod\u016f</p> </li> <li> <p><code>MarkOptionsBase</code></p> </li> <li><code>id: str</code></li> <li><code>abbr: str</code></li> <li><code>text: str</code></li> </ul> <p>Logov\u00e1n\u00ed a fallbacky</p> <ul> <li>Pokud server vr\u00e1t\u00ed <code>MarkText</code>, kter\u00fd nen\u00ed v <code>MarkOptions</code>, do logu se zap\u00ed\u0161e warning a modul pou\u017eije \u201eplaceholder\u201c <code>MarkOptionsBase</code>, aby zpracov\u00e1n\u00ed nespadlo.</li> <li>Pokud server vr\u00e1t\u00ed zn\u00e1mku k nezn\u00e1m\u00e9mu <code>subject_id</code>, modul to zaloguje jako warning a danou zn\u00e1mku p\u0159esko\u010d\u00ed.</li> </ul>"},{"location":"marks/#zakladni-cteni-dat","title":"Z\u00e1kladn\u00ed \u010dten\u00ed dat","text":""},{"location":"marks/#ziskani-seznamu-predmetu","title":"Z\u00edsk\u00e1n\u00ed seznamu p\u0159edm\u011bt\u016f","text":"Seznam p\u0159edm\u011bt\u016f<pre><code>subjects = await marks.get_subjects()\nprint(f\"Na\u010dteno p\u0159edm\u011bt\u016f: {len(subjects)}\")\nfor s in subjects:\n    print(s.id, s.abbr, s.name, s.average_text, s.points_only)\n</code></pre>"},{"location":"marks/#ziskani-znamek-pro-konkretni-predmet","title":"Z\u00edsk\u00e1n\u00ed zn\u00e1mek pro konkr\u00e9tn\u00ed p\u0159edm\u011bt","text":"Zn\u00e1mky pro p\u0159edm\u011bt<pre><code>subject_id = \"SUBJECT_ID\"\nsubject_marks = await marks.get_marks_by_subject(subject_id)\nfor m in subject_marks:\n    print(m.date.date(), m.caption, (m.marktext.text if m.marktext else \"\"))\n</code></pre>"},{"location":"marks/#prace-s-novymi-znamkami","title":"Pr\u00e1ce s nov\u00fdmi zn\u00e1mkami","text":""},{"location":"marks/#vsechny-nove-znamky-napric-predmety","title":"V\u0161echny nov\u00e9 zn\u00e1mky (nap\u0159\u00ed\u010d p\u0159edm\u011bty)","text":"Nov\u00e9 zn\u00e1mky<pre><code>new_marks_grouped = await marks.get_new_marks()\nfor subj in new_marks_grouped:\n    print(subj.name, f\"({subj.abbr})\")\n    for m in subj.marks:\n        print(\" \", m.date.date(), m.caption)\n</code></pre>"},{"location":"marks/#nove-znamky-podle-dne-nebo-rozsahu","title":"Nov\u00e9 zn\u00e1mky podle dne nebo rozsahu","text":"Jeden den Nov\u00e9 zn\u00e1mky v rozsahu<pre><code>from datetime import datetime\n\n# Jeden den\nday = datetime(2025, 9, 12)\nby_day = await marks.get_new_marks_by_date(date_from=day, date_to=day)\n</code></pre> Rozsah dn\u00ed Nov\u00e9 zn\u00e1mky v rozsahu<pre><code>from datetime import datetime\n\n# Rozsah v\u010detn\u011b krajn\u00edch dn\u016f\nstart = datetime(2025, 9, 1)\nend = datetime(2025, 9, 30)\nby_range = await marks.get_new_marks_by_date(date_from=start, date_to=end)\n\n# Jen pro konkr\u00e9tn\u00ed p\u0159edm\u011bt\nby_subject = await marks.get_new_marks_by_date(date_from=start, date_to=end, subject_id=\"SUBJECT_ID\")\n</code></pre>"},{"location":"marks/#kompletni-prehled-znamek-seskupeno-dle-predmetu","title":"Kompletn\u00ed p\u0159ehled zn\u00e1mek (seskupeno dle p\u0159edm\u011bt\u016f)","text":""},{"location":"marks/#vratit-jako-data","title":"Vr\u00e1tit jako data","text":"V\u0161echny zn\u00e1mky (seskupen\u00e9)<pre><code>groups = await marks.get_marks_all()\nfor subj in groups:\n    print(subj.name, f\"({subj.abbr})\")\n    for m in subj.marks:\n        print(\" \", m.date.date(), m.caption)\n</code></pre>"},{"location":"marks/#filtrovat-dle-datarozsahu-anebo-predmetu","title":"Filtrovat dle data/rozsahu a/nebo p\u0159edm\u011btu","text":"Filtrace zn\u00e1mek<pre><code>from datetime import datetime\n\n# v\u0161e v jednom dni\ntext = await marks.format_all_marks(date_from=datetime(2025, 9, 12))\n\n# v rozsahu dat\ntext = await marks.format_all_marks(date_from=datetime(2025, 9, 1), date_to=datetime(2025, 9, 30))\n\n# pouze dan\u00fd p\u0159edm\u011bt\ntext = await marks.format_all_marks(subject_id=\"SUBJECT_ID\")\nprint(text)\n</code></pre>"},{"location":"marks/#plochy-vypis-get_flat","title":"Ploch\u00fd v\u00fdpis (get_flat)","text":"<p>Vr\u00e1t\u00ed zplo\u0161t\u011bl\u00fd seznam zn\u00e1mek se slou\u010den\u00fdmi informacemi o p\u0159edm\u011btu.</p> Ploch\u00fd seznam zn\u00e1mek<pre><code>from datetime import datetime\n\nflat = await marks.get_flat(\n    date_from=datetime(2025, 9, 1),\n    date_to=datetime(2025, 9, 30),\n    order=\"desc\",  # nebo \"asc\"\n)\nfor m in flat:\n    # m je instance FlatMark\n    print(m.id, m.date.date(), m.subject_abbr, m.caption, m.mark_text)\n</code></pre>"},{"location":"marks/#snapshot-get_snapshot","title":"Snapshot (get_snapshot)","text":"<p>Vytvo\u0159\u00ed kompaktn\u00ed sn\u00edmek dat, kter\u00fd obsahuje: - subjects: mapu p\u0159edm\u011bt\u016f podle ID, - marks_grouped: zn\u00e1mky seskupen\u00e9 dle p\u0159edm\u011bt\u016f, - marks_flat: zplo\u0161t\u011bl\u00fd seznam zn\u00e1mek.</p> Snapshot zn\u00e1mek<pre><code>from datetime import datetime\n\nsnapshot = await marks.get_snapshot(\n    date_from=datetime(2025, 9, 1),\n    date_to=datetime(2025, 9, 30),\n    order=\"desc\",   # nebo \"asc\"\n    to_dict=True,   # True \u2192 vr\u00e1t\u00ed dict, False \u2192 vr\u00e1t\u00ed objekty FlatMark\n)\n\n# Struktura snapshotu:\n# snapshot[\"subjects\"] -&gt; { subject_id: { id, abbr, name, average_text, points_only } }\n# snapshot[\"marks_grouped\"] -&gt; { subject_id: [ { ...flat_mark... }, ... ] }\n# snapshot[\"marks_flat\"] -&gt; [ { ...flat_mark... }, ... ]\n</code></pre>"},{"location":"marks/#rozdily-podle-id-diff_ids","title":"Rozd\u00edly podle ID (diff_ids)","text":"<p>Porovn\u00e1 aktu\u00e1ln\u00ed zn\u00e1mky s p\u0159edchoz\u00ed sadou ID a vr\u00e1t\u00ed nov\u00e9 polo\u017eky.</p> Detekce nov\u00fdch zn\u00e1mek<pre><code>from datetime import datetime\n\nprevious_ids = {\"abc\", \"def\"}  # nap\u0159. ulo\u017een\u00e9 z minula\nnew_ids, new_items = await marks.diff_ids(\n    previous_ids,\n    date_from=datetime(2025, 9, 1),\n    date_to=datetime(2025, 9, 30),\n)\n\nprint(\"Nov\u00e1 ID:\", new_ids)\nfor m in new_items:\n    print(m.id, m.date.date(), m.subject_abbr, m.mark_text)\n</code></pre>"},{"location":"marks/#souhrn-get_all_marks_summary","title":"Souhrn (get_all_marks_summary)","text":"<p>Vr\u00e1t\u00ed agregovan\u00fd p\u0159ehled nap\u0159\u00ed\u010d v\u0161emi p\u0159edm\u011bty.</p> Souhrn zn\u00e1mek<pre><code>summary = await marks.get_all_marks_summary()\n# summary = {\n#   \"wavg\": \"...\",                # v\u00e1\u017een\u00fd pr\u016fm\u011br ze zn\u00e1mek (jen \u010d\u00edseln\u00fdch)\n#   \"avg\": \"...\",                 # pr\u016fm\u011br pr\u016fm\u011br\u016f p\u0159edm\u011bt\u016f\n#   \"subjects\": \"N\",              # po\u010det p\u0159edm\u011bt\u016f\n#   \"total_marks\": \"N\",           # celkov\u00fd po\u010det zn\u00e1mek\n#   \"total_point_marks\": \"N\",     # po\u010det bodov\u00fdch zn\u00e1mek\n#   \"total_non_point_marks\": \"N\", # po\u010det ne-bodov\u00fdch zn\u00e1mek\n# }\nprint(summary)\n</code></pre>"},{"location":"marks/api/","title":"P\u0159ehled API","text":""},{"location":"marks/api/#rychla-referencni-api","title":"Rychl\u00e1 referen\u010dn\u00ed API","text":"Hlavn\u00ed metody<pre><code>class Marks:\n    async def fetch_marks(self) -&gt; None: ...\n    async def get_subjects(self) -&gt; list[SubjectsBase]: ...\n    async def get_marks_by_subject(self, subject_id: str) -&gt; list[MarksBase]: ...\n\n    async def get_new_marks(self) -&gt; list[SubjectsBase]: ...\n    async def get_new_marks_by_date(\n        self, date_from: datetime, date_to: datetime, subject_id: str | None = None\n    ) -&gt; list[SubjectsBase]: ...\n\n    async def get_marks_all(\n        self, date_from: datetime | None = None, date_to: datetime | None = None, subject_id: str | None = None\n    ) -&gt; list[SubjectsBase]: ...\n\n    async def format_all_marks(\n        self, date_from: datetime | None = None, date_to: datetime | None = None, subject_id: str | None = None\n    ) -&gt; str: ...\n\n    async def get_flat(\n        self,\n        *,\n        date_from: datetime | None = None,\n        date_to: datetime | None = None,\n        subject_id: str | None = None,\n        order: Literal[\"asc\", \"desc\"] = \"desc\",\n        predicate: Callable[[MarksBase], bool] | None = None,\n    ) -&gt; list[FlatMark]: ...\n\n    async def get_snapshot(\n        self,\n        *,\n        date_from: datetime | None = None,\n        date_to: datetime | None = None,\n        subject_id: str | None = None,\n        order: Literal[\"asc\", \"desc\"] = \"desc\",\n        predicate: Callable[[MarksBase], bool] | None = None,\n        to_dict: bool = True,\n    ) -&gt; FlatSnapshot | dict[str, Any]: ...\n\n    async def get_snapshot_for_school_year(\n        self,\n        *,\n        school_year: tuple[datetime, datetime],\n        order: Literal[\"asc\", \"desc\"] = \"desc\",\n    ) -&gt; FlatSnapshot | dict[str, Any]: ...\n\n    async def diff_ids(\n        self,\n        previous_ids: set[str],\n        *,\n        date_from: datetime | None = None,\n        date_to: datetime | None = None,\n        subject_id: str | None = None,\n        predicate: Callable[[MarksBase], bool] | None = None,\n    ) -&gt; tuple[set[str], list[FlatMark]]: ...\n\n    async def get_all_marks_summary(self) -&gt; dict[str, str]: ...\n</code></pre> <ul> <li><code>get_subjects()</code> \u2014 vrac\u00ed seznam p\u0159edm\u011bt\u016f (ka\u017ed\u00fd <code>SubjectsBase</code> obsahuje vlastn\u00ed <code>MarksRegistry</code>)</li> <li><code>get_marks_by_subject(subject_id)</code> \u2014 vr\u00e1t\u00ed list zn\u00e1mek (<code>MarksBase</code>) pro dan\u00fd p\u0159edm\u011bt</li> <li><code>get_new_marks()</code> \u2014 vrac\u00ed pouze nov\u00e9 zn\u00e1mky (<code>is_new=True</code>) seskupen\u00e9 dle p\u0159edm\u011bt\u016f</li> <li><code>get_new_marks_by_date(date_from, date_to, subject_id=None)</code> \u2014 vrac\u00ed nov\u00e9 zn\u00e1mky v dan\u00e9m dni/rozsahu; voliteln\u011b pouze pro jeden p\u0159edm\u011bt</li> <li><code>get_marks_all(date_from=None, date_to=None, subject_id=None)</code> \u2014 vrac\u00ed v\u0161echny zn\u00e1mky seskupen\u00e9 dle p\u0159edm\u011bt\u016f, s volitelnou filtrac\u00ed</li> <li><code>format_all_marks(date_from=None, date_to=None, subject_id=None)</code> \u2014 vr\u00e1t\u00ed form\u00e1tovan\u00fd textov\u00fd p\u0159ehled</li> <li><code>get_flat(...)</code> \u2014 vr\u00e1t\u00ed zplo\u0161t\u011bl\u00fd seznam zn\u00e1mek (<code>FlatMark</code>) s metadaty p\u0159edm\u011bt\u016f; podporuje \u0159azen\u00ed a predik\u00e1t</li> <li><code>get_snapshot(...)</code> \u2014 vr\u00e1t\u00ed kompaktn\u00ed sn\u00edmek dat: <code>subjects</code>, <code>marks_grouped</code>, <code>marks_flat</code></li> <li><code>get_snapshot_for_school_year(school_year, order=\"desc\")</code> \u2014 vytvo\u0159\u00ed snapshot za zadan\u00fd \u0161koln\u00ed rok (od-do)</li> <li><code>diff_ids(previous_ids, ...)</code> \u2014 porovn\u00e1 ID zn\u00e1mek s p\u0159edchoz\u00ed sadou a vr\u00e1t\u00ed nov\u00e1 ID spolu s nov\u00fdmi polo\u017ekami</li> <li><code>get_all_marks_summary()</code> \u2014 vr\u00e1t\u00ed agregovan\u00fd souhrn nap\u0159\u00ed\u010d v\u0161emi p\u0159edm\u011bty</li> </ul>"},{"location":"timetable/","title":"Modul Timetable","text":"<p>Modul Timetable zaji\u0161\u0165uje na\u010dten\u00ed a zpracov\u00e1n\u00ed rozvrhu (aktu\u00e1ln\u00edho i st\u00e1l\u00e9ho) ze serveru Bakal\u00e1\u0159\u016f. Um\u00ed:</p> <ul> <li>st\u00e1hnout aktu\u00e1ln\u00ed rozvrh pro zadan\u00e9 datum,</li> <li>st\u00e1hnout st\u00e1l\u00fd (permanentn\u00ed) rozvrh,</li> <li>vr\u00e1tit rozparsovan\u00e1 data do p\u0159ehledn\u00fdch t\u0159\u00edd,</li> <li>form\u00e1tovat rozvrh do \u010diteln\u00e9ho textu (den/t\u00fdden).</li> </ul> <p>Tento modul prov\u00e1d\u00ed autorizovan\u00e9 dotazy. P\u0159ed pou\u017eit\u00edm tedy mus\u00edte m\u00edt platn\u00e9 p\u0159ihla\u0161ovac\u00ed \u00fadaje (tokeny) v instanci <code>Bakalari</code>. Viz prvn\u00ed p\u0159ihl\u00e1\u0161en\u00ed a Credentials.</p>"},{"location":"timetable/#trida-timetable","title":"T\u0159\u00edda Timetable","text":"class Timetable<pre><code>from async_bakalari_api import Bakalari\nfrom async_bakalari_api.timetable import Timetable\n\nclass Timetable:\n    \"\"\"Client for fetching and parsing timetable endpoints.\"\"\"\n\n    def __init__(self, bakalari: Bakalari) -&gt; None: ...\n</code></pre> <ul> <li>Konstruktor p\u0159ij\u00edm\u00e1 pouze instanci <code>Bakalari</code>.</li> <li>Modul vyu\u017e\u00edv\u00e1 intern\u011b autorizovan\u00e9 vol\u00e1n\u00ed (<code>send_auth_request</code>) a tokeny si automaticky obnovuje.</li> </ul>"},{"location":"timetable/#pouziti-s-context-managerem","title":"Pou\u017eit\u00ed s context managerem","text":"Context manager<pre><code>from async_bakalari_api import Bakalari\nfrom async_bakalari_api.timetable import Timetable\n\nbakalari = Bakalari(\"https://server_skoly\")\nbakalari.load_credentials(\"credentials.json\")\n\nasync with Timetable(bakalari) as tt:\n    week = await tt.fetch_actual()  # aktu\u00e1ln\u00ed t\u00fdden\n    print(week.format_week())\n</code></pre> <p>Context manager zajist\u00ed otev\u0159en\u00ed/zav\u0159en\u00ed HTTP session p\u0159es <code>Bakalari</code>.</p>"},{"location":"timetable/#filtracni-kontext-timetablecontext","title":"Filtra\u010dn\u00ed kontext (TimetableContext)","text":"<p>Pro filtrov\u00e1n\u00ed rozvrhu (t\u0159\u00edda, skupina, u\u010ditel, u\u010debna, student) se pou\u017e\u00edv\u00e1 <code>TimetableContext</code>. Ten se n\u00e1sledn\u011b p\u0159ev\u00e1d\u00ed na query parametry pro API.</p> TimetableContext<pre><code>from async_bakalari_api.timetable import TimetableContext\n\nctx = TimetableContext(kind=\"class\", id=\"TRIDA_ID\")        # classId=...\n# ctx = TimetableContext(kind=\"group\", id=\"SKUPINA_ID\")    # groupId=...\n# ctx = TimetableContext(kind=\"teacher\", id=\"UCITEL_ID\")   # teacherId=...\n# ctx = TimetableContext(kind=\"room\", id=\"MISTNOST_ID\")    # roomId=...\n# ctx = TimetableContext(kind=\"student\", id=\"STUDENT_ID\")  # studentId=...\n</code></pre> <p>M\u00edsto <code>TimetableContext</code> lze p\u0159edat i p\u0159\u00edmo <code>dict</code> s parametry.</p>"},{"location":"timetable/#hlavni-metody","title":"Hlavn\u00ed metody","text":""},{"location":"timetable/#fetch_actual","title":"fetch_actual","text":"<pre><code>async def fetch_actual(\n    self,\n    for_date: datetime | date | None = None,\n    context: TimetableContext | dict[str, str] | None = None,\n) -&gt; TimetableWeek: ...\n</code></pre> <ul> <li><code>for_date</code>: datum/datetime, pro kter\u00e9 chcete na\u010d\u00edst aktu\u00e1ln\u00ed t\u00fdden (v\u00fdchoz\u00ed: dne\u0161n\u00ed den). Do API se pos\u00edl\u00e1 jako <code>date=YYYY-MM-DD</code>.</li> <li><code>context</code>: filtr rozvrhu (viz <code>TimetableContext</code> nebo dict s parametry).</li> <li>N\u00e1vrat: <code>TimetableWeek</code> \u2013 rozparsovan\u00fd t\u00fdden (viz n\u00ed\u017ee).</li> <li>Vedlej\u0161\u00ed efekt: posledn\u00ed na\u010dten\u00fd aktu\u00e1ln\u00ed t\u00fdden je ulo\u017een v <code>get_last_actual()</code>.</li> </ul> <p>P\u0159\u00edklad:</p> <pre><code>from datetime import date\nfrom async_bakalari_api.timetable import Timetable, TimetableContext\n\ntt = Timetable(bakalari)\nweek = await tt.fetch_actual(for_date=date.today(),\n                             context=TimetableContext(kind=\"class\", id=\"1.A\"))\nprint(week.format_week())\n</code></pre>"},{"location":"timetable/#fetch_permanent","title":"fetch_permanent","text":"<pre><code>async def fetch_permanent(\n    self,\n    context: TimetableContext | dict[str, str] | None = None,\n) -&gt; TimetableWeek: ...\n</code></pre> <ul> <li><code>context</code>: filtr rozvrhu (voliteln\u011b).</li> <li>N\u00e1vrat: <code>TimetableWeek</code>.</li> <li>Vedlej\u0161\u00ed efekt: posledn\u00ed na\u010dten\u00fd st\u00e1l\u00fd t\u00fdden je ulo\u017een v <code>get_last_permanent()</code>.</li> </ul> <p>P\u0159\u00edklad:</p> <pre><code>permanent = await tt.fetch_permanent(context={\"classId\": \"1.A\"})\nprint(permanent.format_week())\n</code></pre>"},{"location":"timetable/#get_last_actual-get_last_permanent","title":"get_last_actual / get_last_permanent","text":"<pre><code>last_actual: TimetableWeek | None = tt.get_last_actual()\nlast_perm: TimetableWeek | None = tt.get_last_permanent()\n</code></pre> <p>Vr\u00e1t\u00ed posledn\u00ed \u00fasp\u011b\u0161n\u011b na\u010dten\u00fd t\u00fdden (nebo <code>None</code>).</p>"},{"location":"timetable/#datove-struktury","title":"Datov\u00e9 struktury","text":""},{"location":"timetable/#timetableweek","title":"TimetableWeek","text":"<p>Kontejner s kompletn\u00edmi daty pro jeden t\u00fdden:</p> <pre><code>class TimetableWeek:\n    hours: dict[int, Hour]\n    days: list[DayEntry]\n    classes: dict[str, ClassEntity]\n    groups: dict[str, GroupEntity]\n    subjects: dict[str, SubjectEntity]\n    teachers: dict[str, TeacherEntity]\n    rooms: dict[str, RoomEntity]\n    cycles: dict[str, CycleEntity]\n\n    def get_day_by_date(self, day: datetime | date) -&gt; DayEntry | None: ...\n    def get_day_by_weekday(self, weekday: int) -&gt; DayEntry | None: ...\n    def resolve(self, atom: Atom) -&gt; tuple[SubjectEntity | None, TeacherEntity | None, RoomEntity | None, list[GroupEntity]]: ...\n    def format_day(self, day: DayEntry) -&gt; str: ...\n    def format_week(self) -&gt; str: ...\n</code></pre> <ul> <li><code>get_day_by_date(...)</code>: vr\u00e1t\u00ed konkr\u00e9tn\u00ed den dle data.</li> <li><code>get_day_by_weekday(weekday)</code>: vr\u00e1t\u00ed den dle indexu dne z API (1=pond\u011bl\u00ed ... 7=ned\u011ble, pokud je k dispozici).</li> <li><code>resolve(atom)</code>: namapuje ID v atomech na konkr\u00e9tn\u00ed entity (p\u0159edm\u011bt, u\u010ditel, m\u00edstnost, skupiny).</li> <li><code>format_day(day)</code>: vr\u00e1t\u00ed \u010diteln\u00fd text pro jeden den.</li> <li><code>format_week()</code>: vr\u00e1t\u00ed \u010diteln\u00fd text pro cel\u00fd t\u00fdden.</li> </ul>"},{"location":"timetable/#hour","title":"Hour","text":"<p>Definice vyu\u010dovac\u00ed hodiny:</p> <pre><code>class Hour:\n    id: int\n    caption: str\n    begin_time: str\n    end_time: str\n</code></pre>"},{"location":"timetable/#dayentry","title":"DayEntry","text":"<p>Jeden den v t\u00fddnu:</p> <pre><code>class DayEntry:\n    day_of_week: int\n    date: datetime\n    description: str\n    day_type: str\n    atoms: list[Atom]\n</code></pre>"},{"location":"timetable/#atom","title":"Atom","text":"<p>Jednotka rozvrhu (hodina/blok), p\u0159\u00edpadn\u011b \u201eplaceholder\u201c se zm\u011bnou:</p> <pre><code>class Atom:\n    hour_id: int\n    group_ids: list[str]\n    subject_id: str | None\n    teacher_id: str | None\n    room_id: str | None\n    cycle_ids: list[str]\n    change: Change | None\n    homework_ids: list[str]\n    theme: str | None\n</code></pre>"},{"location":"timetable/#change","title":"Change","text":"<p>Zm\u011bna v rozvrhu:</p> <pre><code>class Change:\n    change_subject: str | None\n    day: datetime\n    hours: str | None\n    change_type: str | None\n    description: str | None\n    time: str | None\n    type_abbrev: str | None\n    type_name: str | None\n</code></pre>"},{"location":"timetable/#entity","title":"Entity","text":"<p>Z\u00e1kladn\u00ed entity s identifik\u00e1tory (ID jsou ve slovn\u00edc\u00edch ulo\u017eeny jako <code>str</code>):</p> <pre><code>class ClassEntity:   id: str; abbrev: str; name: str\nclass GroupEntity:   class_id: str | None; id: str; abbrev: str; name: str\nclass SubjectEntity: id: str; abbrev: str; name: str\nclass TeacherEntity: id: str; abbrev: str; name: str\nclass RoomEntity:    id: str; abbrev: str; name: str\nclass CycleEntity:   id: str; abbrev: str; name: str\n</code></pre>"},{"location":"timetable/#priklady","title":"P\u0159\u00edklady","text":""},{"location":"timetable/#aktualni-tyden-pro-tridu","title":"Aktu\u00e1ln\u00ed t\u00fdden pro t\u0159\u00eddu","text":"<pre><code>from async_bakalari_api import Bakalari\nfrom async_bakalari_api.timetable import Timetable, TimetableContext\n\nbakalari = Bakalari(\"https://server_skoly\")\nbakalari.load_credentials(\"credentials.json\")\n\ntt = Timetable(bakalari)\nweek = await tt.fetch_actual(context=TimetableContext(kind=\"class\", id=\"1.A\"))\nprint(week.format_week())\n</code></pre>"},{"location":"timetable/#staly-rozvrh-pro-ucitele","title":"St\u00e1l\u00fd rozvrh pro u\u010ditele","text":"<pre><code>teacher_week = await tt.fetch_permanent(context=TimetableContext(kind=\"teacher\", id=\"TCHR_42\"))\nsome_day = teacher_week.get_day_by_weekday(1)  # pond\u011bl\u00ed\nif some_day:\n    print(teacher_week.format_day(some_day))\n</code></pre>"},{"location":"timetable/#rucni-reseni-vazeb-a-formatovani","title":"Ru\u010dn\u00ed \u0159e\u0161en\u00ed vazeb a form\u00e1tov\u00e1n\u00ed","text":"<pre><code># Vypsat prvn\u00ed den a jeho hodiny se subjektem, u\u010ditelem a m\u00edstnost\u00ed\nfirst_day = week.days[0]\nfor atom in first_day.atoms:\n    subj, teach, room, groups = week.resolve(atom)\n    print(atom.hour_id,\n          subj.abbrev if subj else \"\",\n          teach.abbrev if teach else \"\",\n          room.abbrev if room else \"\",\n          \",\".join(g.abbrev for g in groups))\n</code></pre>"},{"location":"timetable/#poznamky-a-chovani","title":"Pozn\u00e1mky a chov\u00e1n\u00ed","text":"<ul> <li>API vrac\u00ed data v r\u016fzn\u00fdch struktur\u00e1ch; parser v modulu se sna\u017e\u00ed b\u00fdt tolerantn\u00ed.</li> <li>Nevalidn\u00ed polo\u017eky se p\u0159esko\u010d\u00ed a do logu se zap\u00ed\u0161e upozorn\u011bn\u00ed (warning).</li> <li>ID se ukl\u00e1daj\u00ed jako \u0159et\u011bzce (o\u0159ezan\u00e9 o p\u0159\u00edpadn\u00e9 b\u00edl\u00e9 znaky).</li> <li>Datum se do endpointu \u201eaktu\u00e1ln\u00ed rozvrh\u201c pos\u00edl\u00e1 jako <code>date=YYYY-MM-DD</code>.</li> <li>Metody <code>format_day</code>/<code>format_week</code> dok\u00e1\u017e\u00ed zobrazit:</li> <li>\u010d\u00edslo hodiny a \u010das,</li> <li>p\u0159edm\u011bt (zkratku),</li> <li>skupiny,</li> <li>u\u010ditele,</li> <li>m\u00edstnost,</li> <li>t\u00e9ma (<code>theme</code>),</li> <li>p\u0159\u00edpadn\u011b i z\u00e1znam o zm\u011bn\u011b (typ/\u010das/popis).</li> <li>Chyby autorizace a s\u00ed\u0165ov\u00e9 chyby se propisuj\u00ed jako v\u00fdjimky definovan\u00e9 v bal\u00ed\u010dku (nap\u0159. <code>Ex.AccessTokenExpired</code>, <code>Ex.RefreshTokenExpired</code>, <code>Ex.BadRequestException</code> aj.). P\u0159i expirovan\u00e9m access tokenu se provede automatick\u00e9 obnoven\u00ed p\u0159es refresh token a po\u017eadavek se zopakuje (max. jednou).</li> </ul>"}]}